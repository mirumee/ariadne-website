"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["78600"],{81056:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>o,toc:()=>l,default:()=>p,metadata:()=>s,assets:()=>u,contentTitle:()=>a});var s=JSON.parse('{"id":"inputs","title":"Inputs","description":"GraphQL Input types are method for collecting logically associated arguments under single GraphQL type.","source":"@site/docs/inputs.md","sourceDirName":".","slug":"/inputs","permalink":"/server/next/inputs","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"inputs","title":"Inputs"},"sidebar":"tutorialSidebar","previous":{"title":"Mutations","permalink":"/server/next/mutations"},"next":{"title":"Error messaging","permalink":"/server/next/error-messaging"}}'),i=t(74848),r=t(84429);let o={id:"inputs",title:"Inputs"},a,u={},l=[{value:"Custom mappings for input dicts",id:"custom-mappings-for-input-dicts",level:2},{value:"Representing GraphQL inputs with custom Python types",id:"representing-graphql-inputs-with-custom-python-types",level:2}];function c(e){let n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"GraphQL Input types are method for collecting logically associated arguments under single GraphQL type."}),"\n",(0,i.jsx)(n.p,{children:"For example, your mutation creating new issue in an issue tracker API could accept multiple arguments:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Mutation {\n    issueCreate(\n        title: String!\n        description: String!\n        labels: [String!]!\n        priority: Int!\n        isClosed: Boolean!\n    ): IssueMutationResult!\n}\n\ntype IssueMutationResult {\n    error: Boolean\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"But you may also gather all those arguments under a single input type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Mutation {\n    issueCreate(\n        input: IssueInput!\n    ): IssueMutationResult!\n}\n\ninput IssueInput {\n    title: String!,\n    description: String!\n    labels: [String!]!\n    priority: Int!\n    isClosed: Boolean!\n}\n\ntype IssueMutationResult {\n    success: Boolean!\n    error: String!\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, when a client wants to create a new issue, they need to provide an ",(0,i.jsx)(n.code,{children:"input"})," object that matches the ",(0,i.jsx)(n.code,{children:"IssueInput"})," definition. This input will then be validated and passed to the mutation's resolver as a ",(0,i.jsx)(n.code,{children:"dict"})," available under the ",(0,i.jsx)(n.code,{children:"input"})," keyword argument:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def resolve_issue_create(_, info, input: dict):\n    clean_input = {\n        "title": input["title"],\n        "description": input["description"],\n        "labels": input["labels"],\n        "priority": input["priority"],\n        "is_closed": input.get("isClosed"),\n    }\n\n    try:\n        create_new_new_issue(info.context, clean_input)\n\n        return {"success": True}\n    except ValidationError as err:\n        return {\n            "success": False,\n            "error": str(err),\n        }\n'})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," Don't worry about ",(0,i.jsx)(n.code,{children:"input"})," and ",(0,i.jsx)(n.code,{children:"clean_input"})," dicts for now. Next chapters of this guide will show you how to customize GraphQL's default behavior using Ariadne's utilities."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Another advantage of ",(0,i.jsx)(n.code,{children:"input"})," types is that they are reusable. If we later decide to implement another mutation for updating the issue, we can do it like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Mutation {\n    issueCreate(\n        input: IssueInput!\n    ): IssueMutationResult!\n    issueUpdate(\n        id: ID!\n        input: IssueInput!\n    ): IssueMutationResult!\n}\n\ninput IssueInput {\n    title: String!,\n    description: String!\n    labels: [String!]!\n    priority: Int!\n    isClosed: Boolean!\n}\n\ntype IssueMutationResult {\n    success: Boolean!\n    error: String!\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Our ",(0,i.jsx)(n.code,{children:"issueUpdate"})," mutation will now accept two arguments: ",(0,i.jsx)(n.code,{children:"id"})," and ",(0,i.jsx)(n.code,{children:"input"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def resolve_issue_update(_, info, id: str, input: dict):\n    issue = get_issue_from_db(id)\n\n    clean_input = {\n        "title": input["title"],\n        "description": input["description"],\n        "labels": input["labels"],\n        "priority": input["priority"],\n        "is_closed": input.get("isClosed"),\n    }\n\n    try:\n        update_issue(info.context, issue, clean_input)\n\n        return {"success": True}\n    except ValidationError as err:\n        return {\n            "success": False,\n            "error": err,\n        }\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You may wonder why you would want to use ",(0,i.jsx)(n.code,{children:"input"})," instead of reusing an already-defined type. This is because input types provide some guarantees that regular objects don't: they are serializable, and they don't implement interfaces or unions. However, input fields are not limited to scalars. You can create fields that are lists, or even reference other inputs:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"input PollInput {\n    question: String!,\n    options: [PollOptionInput!]!\n}\n\ninput PollOptionInput {\n    label: String!\n    color: String!\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Lastly, take a note that inputs are not specific to mutations. You can use inputs for every argument in schema. For example, you can have an input with filtering options for fields returning lists of items."}),"\n",(0,i.jsx)(n.h2,{id:"custom-mappings-for-input-dicts",children:"Custom mappings for input dicts"}),"\n",(0,i.jsxs)(n.p,{children:["In above example input value was represented in Python as ",(0,i.jsx)(n.code,{children:"dict"}),", with extra step for converting original dictionary to ",(0,i.jsx)(n.code,{children:"clean_dict"})," that follows Pythonic convention for naming keys, expected by rest of application's business logic."]}),"\n",(0,i.jsxs)(n.p,{children:["Those initial keys set on input ",(0,i.jsx)(n.code,{children:"dict"}),' by GraphQL are called "out names" and default to names of input\'s fields in GraphQL schema. Ariadne provides ',(0,i.jsx)(n.code,{children:"InputType"})," utility that enables customization of those names."]}),"\n",(0,i.jsxs)(n.p,{children:["We can replace the logic used to create ",(0,i.jsx)(n.code,{children:"clean_input"})," with ",(0,i.jsx)(n.code,{children:"InputType"}),"'s ",(0,i.jsx)(n.code,{children:"out_names"})," option:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from ariadne import InputType, MutationType, gql, make_executable_schema\n\ntype_defs = gql(\n    """\n    type Query {\n        unused: Boolean\n    }\n\n    type Mutation {\n        issueCreate(\n            input: IssueInput!\n        ): IssueMutationResult!\n    }\n\n    input IssueInput {\n        title: String!,\n        description: String!\n        labels: [String!]!\n        priority: Int!\n        isClosed: Boolean!\n    }\n\n    type IssueMutationResult {\n        success: Boolean!\n        error: String!\n    }\n    """\n)\n\nmutation_type = MutationType()\n\n@mutation_type.field("issueCreate")\ndef resolve_issue_create(_, info, input: dict):\n    try:\n        create_new_new_issue(info.context, input)\n\n        return {"success": True}\n    except ValidationError as err:\n        return {\n            "success": False,\n            "error": str(err),\n        }\n\n\nschema = make_executable_schema(\n    type_defs,\n    mutation_type,\n    InputType("IssueInput", out_names={"isClosed": "is_closed"}),\n)\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"InputType"})," utility accepts few arguments, but in this section we will focus on two:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["First argument, ",(0,i.jsx)(n.code,{children:"name"}),", is a string of input type in GraphQL schema which's behavior we want to customize."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"out_names"})," option is a ",(0,i.jsx)(n.code,{children:"dict"})," with Python out names (",(0,i.jsx)(n.code,{children:"dict"})," values) for input fields (",(0,i.jsx)(n.code,{children:"dict"})," keys)."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In the above example we are using the ",(0,i.jsx)(n.code,{children:"out_names"})," option of ",(0,i.jsx)(n.code,{children:"InputType"})," to tell GraphQL that in Python ",(0,i.jsx)(n.code,{children:"dict"})," with input data, ",(0,i.jsx)(n.code,{children:"isClosed"})," field's value should be put under the ",(0,i.jsx)(n.code,{children:"is_closed"})," key."]}),"\n",(0,i.jsxs)(n.p,{children:["We are passing this value as named argument because ",(0,i.jsx)(n.code,{children:"out_names"})," is actually a third argument of ",(0,i.jsx)(n.code,{children:"InputType"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," Instead of setting the ",(0,i.jsx)(n.code,{children:"out_names"})," option for each input type, you can enable the ",(0,i.jsx)(n.code,{children:"convert_names_case"})," option on ",(0,i.jsx)(n.code,{children:"make_executable_schema"})," to set those automatically for entire schema."]}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"/server/next/case-conversion",children:"this guide"})," for the details."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"representing-graphql-inputs-with-custom-python-types",children:"Representing GraphQL inputs with custom Python types"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"InputType"}),"'s second and more powerful option is setting GraphQL input's \"out type\". \"Out type\" is custom deserialization logic that's ran by GraphQL against input's final ",(0,i.jsx)(n.code,{children:"dict"})," (",(0,i.jsx)(n.code,{children:"dict"})," created using ",(0,i.jsx)(n.code,{children:"out_names"}),"). This custom logic can be used to do anything with input's ",(0,i.jsx)(n.code,{children:"dict"})," data, included converting it other Python type."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, we could represent ",(0,i.jsx)(n.code,{children:"IssueInput"})," in Python as data class:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from dataclasses import dataclass\nfrom typing import List, Optional\n\n\n@dataclass\nclass IssueInput:\n    title: str\n    description: str\n    labels: List[str]\n    priority: int\n    is_closed: Optional[bool] = None\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then we could define custom logic converting dict with input's data to this class:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_issue_input_repr(data: dict) -> IssueInput:\n    return IssueInput(**data)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Finally, we need update ",(0,i.jsx)(n.code,{children:"InputType"})," to use this function for creating Python representation of ",(0,i.jsx)(n.code,{children:"IssueInput"})," GraphQL type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'schema = make_executable_schema(\n    type_defs,\n    mutation_type,\n    InputType(\n        "IssueInput",\n        get_issue_input_repr,\n        {"isClosed": "is_closed"},\n    ),\n)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["But in final code we can use lambda function instead of ",(0,i.jsx)(n.code,{children:"get_issue_input_repr"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from dataclasses import dataclass\nfrom typing import List, Optional\n\nfrom ariadne import InputType, MutationType, gql, make_executable_schema\n\ntype_defs = gql(\n    """\n    type Query {\n        unused: Boolean\n    }\n\n    type Mutation {\n        issueCreate(\n            input: IssueInput!\n        ): IssueMutationResult!\n    }\n\n    input IssueInput {\n        title: String!,\n        description: String!\n        labels: [String!]!\n        priority: Int!\n        isClosed: Boolean!\n    }\n\n    type IssueMutationResult {\n        success: Boolean!\n        error: String!\n    }\n    """\n)\n\n\n@dataclass\nclass IssueInput:\n    title: str\n    description: str\n    labels: List[str]\n    priority: int\n    is_closed: Optional[bool] = None\n\n\nmutation_type = MutationType()\n\n@mutation_type.field("issueCreate")\ndef resolve_issue_create(_, info, input: IssueInput):\n    try:\n        create_new_new_issue(info.context, input)\n\n        return {"success": True}\n    except ValidationError as err:\n        return {\n            "success": False,\n            "error": str(err),\n        }\n\n\nschema = make_executable_schema(\n    type_defs,\n    mutation_type,\n    InputType(\n        "IssueInput",\n        lambda data: IssueInput(**data),\n        {"isClosed": "is_closed"},\n    ),\n)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Thats it! ",(0,i.jsx)(n.code,{children:"IssueInput"})," in GraphQL schema will now be represented as ",(0,i.jsx)(n.code,{children:"IssueInput"})," dataclass in Python logic."]})]})}function p(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},84429:function(e,n,t){t.d(n,{R:()=>o,x:()=>a});var s=t(96540);let i={},r=s.createContext(i);function o(e){let n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);