"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["45459"],{24911:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>o,toc:()=>c,default:()=>u,metadata:()=>s,assets:()=>l,contentTitle:()=>r});var s=JSON.parse('{"id":"mutations","title":"Mutations","description":"All the previous examples in this documentation have dealt with the Query root type and reading data. What about creating, updating or deleting data?","source":"@site/server_versioned_docs/version-0.16/mutations.md","sourceDirName":".","slug":"/mutations","permalink":"/server/0.16/mutations","draft":false,"unlisted":false,"tags":[],"version":"0.16","frontMatter":{"id":"mutations","title":"Mutations"},"sidebar":"tutorialSidebar","previous":{"title":"Resolvers","permalink":"/server/0.16/resolvers"},"next":{"title":"Error messaging","permalink":"/server/0.16/error-messaging"}}'),i=t(74848),a=t(84429);let o={id:"mutations",title:"Mutations"},r,l={},c=[{value:"Defining mutations",id:"defining-mutations",level:2},{value:"Writing resolvers",id:"writing-resolvers",level:2},{value:"Mutation payloads",id:"mutation-payloads",level:2},{value:"Inputs",id:"inputs",level:2}];function d(e){let n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["All the previous examples in this documentation have dealt with the ",(0,i.jsx)(n.code,{children:"Query"})," root type and reading data. What about creating, updating or deleting data?"]}),"\n",(0,i.jsxs)(n.p,{children:["Enter the ",(0,i.jsx)(n.code,{children:"Mutation"})," type, ",(0,i.jsx)(n.code,{children:"Query"}),"'s sibling that GraphQL servers use to implement functions that change application state."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Because there is no restriction on what can be done inside resolvers, technically there's nothing stopping somebody from making ",(0,i.jsx)(n.code,{children:"Query"})," fields act as ",(0,i.jsx)(n.code,{children:"Mutation"}),"s, taking inputs and executing state-changing logic."]}),"\n",(0,i.jsx)(n.p,{children:"In practice, such queries break the contract with client libraries such as Apollo-Client that do client-side caching and state management, resulting in non-responsive controls or inaccurate information being displayed in the UI as the library displays cached data before redrawing it to display an actual response from the GraphQL."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"defining-mutations",children:"Defining mutations"}),"\n",(0,i.jsx)(n.p,{children:"Let's define the basic schema that implements a simple authentication mechanism allowing the client to see if they are authenticated, and to log in and log out:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'type_def = """\n    type Query {\n        isAuthenticated: Boolean!\n    }\n\n    type Mutation {\n        login(username: String!, password: String!): Boolean!\n        logout: Boolean!\n    }\n"""\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this example we have the following elements:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Query"})," type with single field: a boolean for checking if we are authenticated or not. It may appear superficial for the sake of this example, ",(0,i.jsx)(n.em,{children:"but Ariadne requires"})," that your GraphQL API always defines a ",(0,i.jsx)(n.code,{children:"Query"})," type."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Mutation"})," type with two mutations:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"login"})," mutation that requires username and password strings and returns a boolean indicating status."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"logout"})," that takes no arguments and just returns status."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"writing-resolvers",children:"Writing resolvers"}),"\n",(0,i.jsxs)(n.p,{children:["Mutation resolvers are no different than resolvers used by other types. They are functions that take ",(0,i.jsx)(n.code,{children:"parent"})," and ",(0,i.jsx)(n.code,{children:"info"})," arguments, as well as any mutation's arguments as keyword arguments. They then return data that should be sent to the client as a query result:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def resolve_login(_, info, username, password):\n    request = info.context["request"]\n    user = auth.authenticate(username, password)\n    if user:\n        auth.login(request, user)\n        return True\n    return False\n\n\ndef resolve_logout(_, info):\n    request = info.context["request"]\n    if request.user.is_authenticated:\n        auth.logout(request)\n        return True\n    return False\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You can map resolvers to mutations using a ",(0,i.jsx)(n.code,{children:"MutationType"})," object:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from ariadne import MutationType\nfrom . import auth_mutations\n\nmutation = MutationType()\nmutation.set_field("login", auth_mutations.resolve_login)\nmutation.set_field("logout", auth_mutations.resolve_logout)\n'})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"MutationType()"})," is just a shortcut for ",(0,i.jsx)(n.code,{children:'ObjectType("Mutation")'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"MutationType"})," objects include a ",(0,i.jsx)(n.code,{children:"field()"})," decorator for mapping resolvers to mutations:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'mutation = MutationType()\n\n@mutation.field("logout")\ndef resolve_logout(_, info):\n    ...\n'})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Binding Mutation Resolvers"})}),"\n",(0,i.jsxs)(n.p,{children:["Recall that resolvers need to be bound to their respective resolvers via the ",(0,i.jsx)(n.code,{children:"make_executable_schema"})," call. If you're following along from the introduction that call will look similar to the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"make_executable_schema(type_defs, [query, mutations])\n"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"mutation-payloads",children:"Mutation payloads"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"login"})," and ",(0,i.jsx)(n.code,{children:"logout"})," mutations introduced earlier in this guide work, but give very limited feedback to the client: they return either ",(0,i.jsx)(n.code,{children:"False"})," or ",(0,i.jsx)(n.code,{children:"True"}),". The application could use additional information like an error message that could be displayed in the interface if the mutation request fails, or a user state updated after a mutation completed."]}),"\n",(0,i.jsxs)(n.p,{children:["In GraphQL this is achieved by making mutations return special ",(0,i.jsx)(n.em,{children:"payload"})," types containing additional information about the result, such as errors or current object state:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'type_def = """\n    type Mutation {\n        login(username: String!, password: String!): LoginPayload\n    }\n\n    type LoginPayload {\n        status: Boolean!\n        error: Error\n        user: User\n    }\n"""\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The above mutation will return a special type containing information about the mutation's status, as well as either an ",(0,i.jsx)(n.code,{children:"Error"})," message or a logged in ",(0,i.jsx)(n.code,{children:"User"}),". In Python this payload can be represented as a simple ",(0,i.jsx)(n.code,{children:"dict"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def resolve_login(_, info, username, password):\n    request = info.context["request"]\n    user = auth.authenticate(username, password)\n    if user:\n        auth.login(request, user)\n        return {"status": True, "user": user}\n    return {"status": False, "error": "Invalid username or password"}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Let's take one more look at the payload's fields:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"status"})," makes it easier for the frontend logic to check if mutation succeeded or not."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"error"})," contains an error message returned by mutation or ",(0,i.jsx)(n.code,{children:"null"}),". Errors can be simple strings, or more complex types that contain additional information for use by the client."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"user"})," field is especially noteworthy. Modern GraphQL client libraries like ",(0,i.jsx)(n.a,{href:"https://www.apollographql.com/docs/react/",children:"Apollo Client"})," implement automatic caching and state management, using GraphQL types to track and automatically update stored object data whenever a new one is returned from the API."]}),"\n",(0,i.jsx)(n.p,{children:"Consider a mutation that changes a user's username and its payload:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Mutation {\n  updateUsername(id: ID!, username: String!): userMutationPayload\n}\n\ntype UsernameMutationPayload {\n  status: Boolean!\n  error: Error\n  user: User\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Our client code may first perform an ",(0,i.jsx)(n.em,{children:"optimistic update"})," before the API executes a mutation and returns a response to client. This optimistic update will cause an immediate update of the application interface, making it appear fast and responsive to the user. When the mutation eventually completes a moment later and returns an updated ",(0,i.jsx)(n.code,{children:"user"})," one of two things will happen:"]}),"\n",(0,i.jsx)(n.p,{children:"If the mutation succeeded, the user doesn't see another UI update because the new data returned by the mutation was the same as the one set by the optimistic update. If the mutation asked for additional user fields that are dependant on username but weren't set optimistically (like link or user name changes history), those will be updated too."}),"\n",(0,i.jsxs)(n.p,{children:["If the mutation failed, changes performed by an optimistic update are overwritten by valid user state that contains the pre-changed username. The client then uses the ",(0,i.jsx)(n.code,{children:"error"})," field to display an error message in the interface."]}),"\n",(0,i.jsx)(n.p,{children:"For the above reasons it is considered a good design for mutations to return an updated object whenever possible."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["There is no requirement for every mutation to have its own ",(0,i.jsx)(n.code,{children:"Payload"})," type. ",(0,i.jsx)(n.code,{children:"login"})," and ",(0,i.jsx)(n.code,{children:"logout"})," mutations can both define ",(0,i.jsx)(n.code,{children:"LoginPayload"})," as their return type. It is up to the developer to decide how generic or specific mutation payloads should be."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(n.p,{children:"Let's consider the following type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Discussion {\n  category: Category!\n  poster: User\n  postedOn: Date!\n  title: String!\n  isAnnouncement: Boolean!\n  isClosed: Boolean!\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Imagine a mutation for creating ",(0,i.jsx)(n.code,{children:"Discussion"}),"s that takes category, poster, title, announcement and closed states as inputs, and creates a new ",(0,i.jsx)(n.code,{children:"Discussion"})," in the database. Looking at the previous example, we may want to define it like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Mutation {\n  createDiscussion(\n    category: ID!\n    title: String!\n    isAnnouncement: Boolean\n    isClosed: Boolean\n  ): DiscussionPayload\n}\n\ntype DiscussionPayload {\n  status: Boolean!\n  error: Error\n  discussion: Discussion\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Our mutation takes only four arguments, but it is already too unwieldy to work with. Imagine adding another one or two arguments to it in future - it's going to explode!"}),"\n",(0,i.jsxs)(n.p,{children:["GraphQL provides a better way for solving this problem: ",(0,i.jsx)(n.code,{children:"input"})," allows us to move arguments into a dedicated type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Mutation {\n  createDiscussion(input: DiscussionInput!): DiscussionPayload\n}\n\ninput DiscussionInput {\n  category: ID!\n  title: String!\n  isAnnouncement: Boolean\n  isClosed: Boolean\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, when a client wants to create a new discussion, it needs to provide an ",(0,i.jsx)(n.code,{children:"input"})," object that matches the ",(0,i.jsx)(n.code,{children:"DiscussionInput"})," definition. This input will then be validated and passed to the mutation's resolver as a ",(0,i.jsx)(n.code,{children:"dict"})," available under the ",(0,i.jsx)(n.code,{children:"input"})," keyword argument:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def resolve_create_discussion(_, info, input):\n    clean_input = {\n        "category": input["category"],\n        "title": input["title"],\n        "is_announcement": input.get("isAnnouncement"),\n        "is_closed": input.get("isClosed"),\n    }\n\n    try:\n        return {\n            "status": True,\n            "discussion": create_new_discussion(info.context, clean_input),\n        }\n    except ValidationError as err:\n        return {\n            "status": False,\n            "error": err,\n        }\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Another advantage of ",(0,i.jsx)(n.code,{children:"input"})," types is that they are reusable. If we later decide to implement another mutation for updating the ",(0,i.jsx)(n.code,{children:"Discussion"}),", we can do it like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Mutation {\n  createDiscussion(input: DiscussionInput!): DiscussionPayload\n  updateDiscussion(discussion: ID!, input: DiscussionInput!): DiscussionPayload\n}\n\ninput DiscussionInput {\n  category: ID!\n  title: String!\n  isAnnouncement: Boolean\n  isClosed: Boolean\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Our ",(0,i.jsx)(n.code,{children:"updateDiscussion"})," mutation will now accept two arguments: ",(0,i.jsx)(n.code,{children:"discussion"})," and ",(0,i.jsx)(n.code,{children:"input"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def resolve_update_discussion(_, info, discussion, input):\n    clean_input = {\n        "category": input["category"],\n        "title": input["title"],\n        "is_announcement": input.get("isAnnouncement"),\n        "is_closed": input.get("isClosed"),\n    }\n\n    try:\n        return {\n            "status": True,\n            "discussion": update_discussion(info.context, discussion, clean_input),\n        }\n    except ValidationError as err:\n        return {\n            "status": False,\n            "error": err,\n        }\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You may wonder why you would want to use ",(0,i.jsx)(n.code,{children:"input"})," instead of reusing an already-defined type. This is because input types provide some guarantees that regular objects don't: they are serializable, and they don't implement interfaces or unions. However, input fields are not limited to scalars. You can create fields that are lists, or even reference other inputs:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"input PollInput {\n  question: String!\n  options: [PollOptionInput!]!\n}\n\ninput PollOptionInput {\n  label: String!\n  color: String!\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Lastly, take note that inputs are not specific to mutations. You can create inputs to implement complex filtering in your ",(0,i.jsx)(n.code,{children:"Query"})," fields."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," you can decorate your resolvers with ",(0,i.jsx)(n.a,{href:"/server/0.16/api-reference#convert_kwargs_to_snake_case",children:(0,i.jsx)(n.code,{children:"convert_kwargs_to_snake_case"})})," to convert arguments and inputs names from ",(0,i.jsx)(n.code,{children:"camelCase"})," to ",(0,i.jsx)(n.code,{children:"snake_case"}),"."]}),"\n"]})]})}function u(e={}){let{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},84429:function(e,n,t){t.d(n,{R:()=>o,x:()=>r});var s=t(96540);let i={},a=s.createContext(i);function o(e){let n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);