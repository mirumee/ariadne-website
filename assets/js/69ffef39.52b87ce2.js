"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["68158"],{44792:function(e,n,s){s.r(n),s.d(n,{frontMatter:()=>l,toc:()=>d,default:()=>h,metadata:()=>r,assets:()=>o,contentTitle:()=>i});var r=JSON.parse('{"id":"resolvers","title":"Resolvers","description":"In Ariadne, a resolver is any Python callable that accepts two positional arguments (obj and info):","source":"@site/server_versioned_docs/version-0.8.0/resolvers.md","sourceDirName":".","slug":"/resolvers","permalink":"/server/0.8.0/resolvers","draft":false,"unlisted":false,"tags":[],"version":"0.8.0","frontMatter":{"id":"resolvers","title":"Resolvers"},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/server/0.8.0/intro"},"next":{"title":"Mutations","permalink":"/server/0.8.0/mutations"}}'),t=s(74848),a=s(84429);let l={id:"resolvers",title:"Resolvers"},i,o={},d=[{value:"Binding resolvers",id:"binding-resolvers",level:2},{value:"Handling arguments",id:"handling-arguments",level:2},{value:"Aliases",id:"aliases",level:2},{value:"Fallback resolvers",id:"fallback-resolvers",level:2},{value:"Default resolver",id:"default-resolver",level:2},{value:"Query shortcut",id:"query-shortcut",level:2}];function c(e){let n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["In Ariadne, a resolver is any Python callable that accepts two positional arguments (",(0,t.jsx)(n.code,{children:"obj"})," and ",(0,t.jsx)(n.code,{children:"info"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def example_resolver(obj: Any, info: GraphQLResolveInfo):\n    return obj.do_something()\n\nclass FormResolver:\n    def __call__(self, obj: Any, info: GraphQLResolveInfo, **data):\n        ...\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"obj"})," is a value returned by a parent resolver. If the resolver is a ",(0,t.jsx)(n.em,{children:"root resolver"})," (it belongs to the field defined on ",(0,t.jsx)(n.code,{children:"Query"}),", ",(0,t.jsx)(n.code,{children:"Mutation"})," or ",(0,t.jsx)(n.code,{children:"Subscription"}),") and the GraphQL server implementation doesn't explicitly define value for this field, the value of this argument will be ",(0,t.jsx)(n.code,{children:"None"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"info"})," is the instance of a ",(0,t.jsx)(n.code,{children:"GraphQLResolveInfo"})," object specific for this field and query. It defines a special ",(0,t.jsx)(n.code,{children:"context"})," attribute that contains any value that GraphQL server provided for resolvers on the query execution. Its type and contents are application-specific, but it is generally expected to contain application-specific data such as authentication state of the user or an HTTP request."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"context"})," is just one of many attributes that can be found on ",(0,t.jsx)(n.code,{children:"GraphQLResolveInfo"}),", but it is by far the most commonly used one. Other attributes enable developers to introspect the query that is currently executed and implement new utilities and abstractions, but documenting that is out of Ariadne's scope. If you are interested, you can find the list of all attributes ",(0,t.jsx)(n.a,{href:"https://github.com/graphql-python/graphql-core-next/blob/v1.0.5/graphql/type/definition.py#L487",children:"here"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"binding-resolvers",children:"Binding resolvers"}),"\n",(0,t.jsx)(n.p,{children:"A resolver needs to be bound to a valid type's field in the schema in order to be used during the query execution."}),"\n",(0,t.jsxs)(n.p,{children:["To bind resolvers to schema, Ariadne uses a special ",(0,t.jsx)(n.code,{children:"ObjectType"})," class that is initialized with a single argument: the name of the type defined in the schema:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from ariadne import ObjectType\n\nquery = ObjectType("Query")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The above ",(0,t.jsx)(n.code,{children:"ObjectType"})," instance knows that it maps its resolvers to ",(0,t.jsx)(n.code,{children:"Query"})," type, and enables you to assign resolver functions to these type fields. This can be done using the ",(0,t.jsx)(n.code,{children:"field"})," decorator implemented by the resolver map:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from ariadne import ObjectType, make_executable_schema\n\ntype_defs = """\n    type Query {\n        hello: String!\n    }\n"""\n\nquery = ObjectType("Query")\n\n@query.field("hello")\ndef resolve_hello(*_):\n    return "Hello!"\n\n\nschema = make_executable_schema(type_defs, query)\n'})}),"\n",(0,t.jsx)(n.p,{children:"If you need to add resolvers for another type, you can pass it as another argument to the executable schema:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from ariadne import ObjectType, make_executable_schema\n\ntype_defs = """\n    type Query {\n        hello: String!\n        user: User\n    }\n\n    type User {\n        name: String!\n    }\n"""\n\nquery = ObjectType("Query")\n\n@query.field("user")\ndef resolve_user(_, info):\n    return {"first_name": "John", "last_name": "Lennon"}\n\n\nuser = ObjectType("User")\n\n@user.field("username")\ndef resolve_username(obj, *_):\n    return f"{obj[\'first_name\']} {obj[\'last_name\']}"\n\n\nschema = make_executable_schema(type_defs, query, user)\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Note"})}),"\n",(0,t.jsxs)(n.p,{children:["In previous versions of Ariadne recommended approach to passing multiple bindables to ",(0,t.jsx)(n.code,{children:"make_executable_schema"})," was to combine those into a list:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"schema = make_executable_schema(type_defs, [query, user])\n"})}),"\n",(0,t.jsx)(n.p,{children:"This pattern is still supported for backwards compatibility reasons, but it may be deprecated in future version of Ariadne."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"@query.field"})," decorator is non-wrapping - it simply registers a given function as a resolver for the specified field and then returns it as it is. This makes it easy to test or reuse resolver functions between different types or even APIs:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'user = ObjectType("User")\nclient = ObjectType("Client")\n\n@user.field("email")\n@client.field("email")\ndef resolve_email_with_permission_check(obj, info):\n    if info.context["user"].is_administrator:\n        return obj.email\n    return None\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Alternatively, ",(0,t.jsx)(n.code,{children:"set_field"})," method can be used to set function as field's resolver:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from .resolvers import resolve_email_with_permission_check\n\nuser = ObjectType("User")\nuser.set_field("email", resolve_email_with_permission_check)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"handling-arguments",children:"Handling arguments"}),"\n",(0,t.jsx)(n.p,{children:"If a GraphQL field specifies any arguments, those argument values will be passed to the resolver as keyword arguments:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'type_def = """\n    type Query {\n        holidays(year: Int): [String]!\n    }\n"""\n\nquery = ObjectType("Query")\n\n@query.field("holidays")\ndef resolve_holidays(*_, year=None):\n    if year:\n        Calendar.get_holidays_in_year(year)\n    return Calendar.get_all_holidays()\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If a field argument is marked as required (by following its type with ",(0,t.jsx)(n.code,{children:"!"}),", eg. ",(0,t.jsx)(n.code,{children:"year: Int!"}),"), you can skip the ",(0,t.jsx)(n.code,{children:"=None"})," in your ",(0,t.jsx)(n.code,{children:"kwarg"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'@query.field("holidays")\ndef resolve_holidays(*_, year):\n    if year:\n        Calendar.get_holidays_in_year(year)\n    return Calendar.get_all_holidays()\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," You can decorate your resolvers with ",(0,t.jsx)(n.a,{href:"/server/0.8.0/api-reference#convert_kwargs_to_snake_case",children:(0,t.jsx)(n.code,{children:"convert_kwargs_to_snake_case"})})," to convert arguments and inputs names from ",(0,t.jsx)(n.code,{children:"camelCase"})," to ",(0,t.jsx)(n.code,{children:"snake_case"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"aliases",children:"Aliases"}),"\n",(0,t.jsxs)(n.p,{children:["You can use ",(0,t.jsx)(n.code,{children:"ObjectType.set_alias"})," to quickly make a field an alias for a differently-named attribute on a resolved object:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'type_def = """\n    type User {\n        fullName: String\n    }\n""" \n\nuser = ObjectType("User")\nuser.set_alias("fullName", "username")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"fallback-resolvers",children:"Fallback resolvers"}),"\n",(0,t.jsx)(n.p,{children:"Schema can potentially define numerous types and fields, and defining a resolver or alias for every single one of them can become a large burden."}),"\n",(0,t.jsx)(n.p,{children:'Ariadne provides two special "fallback resolvers" that scan schema during initialization, and bind default resolvers to fields that don\'t have any resolver set:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from ariadne import fallback_resolvers, make_executable_schema\nfrom .typedefs import type_defs\nfrom .resolvers import resolvers\n\nschema = make_executable_schema(type_defs, resolvers, fallback_resolvers)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The above example creates an executable schema using types and resolvers imported from other modules, but it also adds ",(0,t.jsx)(n.code,{children:"fallback_resolvers"})," to the list of bindables that should be used in creation of the schema."]}),"\n",(0,t.jsxs)(n.p,{children:["Resolvers set by ",(0,t.jsx)(n.code,{children:"fallback_resolvers"}),' don\'t perform any case conversion and simply seek the attribute named in the same way as the field they are bound to using the "default resolver" strategy described in the next chapter.']}),"\n",(0,t.jsxs)(n.p,{children:["If your schema uses JavaScript convention for naming its fields (as do all schema definitions in this guide) you may want to instead use the ",(0,t.jsx)(n.code,{children:"snake_case_fallback_resolvers"})," that converts field name to Python's ",(0,t.jsx)(n.code,{children:"snake_case"})," before looking it up on the object:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from ariadne import snake_case_fallback_resolvers, make_executable_schema\nfrom .typedefs import type_defs\nfrom .resolvers import resolvers\n\nschema = make_executable_schema(type_defs, resolvers, snake_case_fallback_resolvers)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"default-resolver",children:"Default resolver"}),"\n",(0,t.jsxs)(n.p,{children:["Both ",(0,t.jsx)(n.code,{children:"ObjectType.alias"})," and fallback resolvers use a default resolver provided by ",(0,t.jsx)(n.code,{children:"graphql-core-next"})," library to implement its functionality."]}),"\n",(0,t.jsxs)(n.p,{children:["This resolver takes a target attribute name and (depending if ",(0,t.jsx)(n.code,{children:"obj"})," is a ",(0,t.jsx)(n.code,{children:"dict"})," or not) uses either ",(0,t.jsx)(n.code,{children:"obj.get(attr_name)"})," or ",(0,t.jsx)(n.code,{children:"getattr(obj, attr_name, None)"})," to resolve the value that should be returned. If the resolved value is callable, it is called with arguments that were passed to the resolver field, and its return value is then used instead."]}),"\n",(0,t.jsxs)(n.p,{children:["In the below example, both representations of ",(0,t.jsx)(n.code,{children:"User"})," type are supported by the default resolver:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'type_def = """\n    type User {\n        username: String!\n        likes: Int!\n        initials(length: Int!): String\n    }\n"""\n\nclass UserObj:\n    username = "admin"\n\n    def likes(self):\n        return count_user_likes(self)\n\n    def initials(self, length):\n        return self.name[:length]\n\nuser_dict = {\n    "username": "admin",\n    "likes": lambda obj, *_: count_user_likes(obj),\n    "initials": lambda obj, *_, length: obj.username[:length]\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"query-shortcut",children:"Query shortcut"}),"\n",(0,t.jsxs)(n.p,{children:["Ariadne defines the ",(0,t.jsx)(n.code,{children:"QueryType"})," shortcut that you can use in place of ",(0,t.jsx)(n.code,{children:'ObjectType("Query")'}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from ariadne import QueryType\n\ntype_def = """\n    type Query {\n        systemStatus: Boolean!\n    }\n"""\n\nquery = QueryType()\n\n@query.field("systemStatus")\ndef resolve_system_status(*_):\n    ...\n'})})]})}function h(e={}){let{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},84429:function(e,n,s){s.d(n,{R:()=>l,x:()=>i});var r=s(96540);let t={},a=r.createContext(t);function l(e){let n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);