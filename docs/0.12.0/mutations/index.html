<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Mutations · Ariadne</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;All the previous examples in this documentation have dealt with the &lt;code&gt;Query&lt;/code&gt; root type and reading data. What about creating, updating or deleting data?&lt;/p&gt;
"/><meta name="docsearch:version" content="0.12.0"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Mutations · Ariadne"/><meta property="og:type" content="website"/><meta property="og:url" content="https://ariadnegraphql.org/"/><meta property="og:description" content="&lt;p&gt;All the previous examples in this documentation have dealt with the &lt;code&gt;Query&lt;/code&gt; root type and reading data. What about creating, updating or deleting data?&lt;/p&gt;
"/><meta property="og:image" content="https://ariadnegraphql.org/img/share-image.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://ariadnegraphql.org/img/twitter-image.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://ariadnegraphql.org/blog/atom.xml" title="Ariadne Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://ariadnegraphql.org/blog/feed.xml" title="Ariadne Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-10159761-23', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/css/prism.css"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo-horizontal.png" alt="Ariadne"/></a><a href="/versions"><h3>0.12.0</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class="siteNavGroupActive"><a href="/docs/0.12.0/intro" target="_self">Docs</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class=""><a href="/community" target="_self">Community</a></li><li class=""><a href="https://github.com/mirumee/ariadne" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Docs</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Docs</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/0.12.0/intro">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/resolvers">Resolvers</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/0.12.0/mutations">Mutations</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/error-messaging">Error messaging</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/scalars">Custom scalars</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/enums">Enumeration types</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/unions">Union types</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/interfaces">Interface types</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/subscriptions">Subscriptions</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/file-uploads">File uploads</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/documenting-schema">Documenting schema</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/modularization">Modularization</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/bindables">Bindables</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/schema-directives">Schema directives</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/local-development">Local development</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/logging">Logging</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/apollo-federation">Apollo Federation</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Monitoring</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/0.12.0/apollo-tracing">Apollo Tracing</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/open-tracing">OpenTracing</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Servers</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/0.12.0/asgi">ASGI application</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/wsgi">WSGI application</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Integrations</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/0.12.0/django-integration">Django</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/flask-integration">Flask</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/starlette-integration">Starlette</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/other-integrations">Other technologies</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extensions</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/0.12.0/extensions">Extension system</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/middleware">Middleware</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/query-validators">Query validators</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API reference</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/0.12.0/api-reference">ariadne</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/constants-reference">ariadne.constants</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/exceptions-reference">ariadne.exceptions</a></li><li class="navListItem"><a class="navItem" href="/docs/0.12.0/types-reference">ariadne.types</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Other</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/0.12.0/logo">Ariadne logo</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Mutations</h1></header><article><div><span><p>All the previous examples in this documentation have dealt with the <code>Query</code> root type and reading data. What about creating, updating or deleting data?</p>
<p>Enter the <code>Mutation</code> type, <code>Query</code>'s sibling that GraphQL servers use to implement functions that change application state.</p>
<blockquote>
<p>Because there is no restriction on what can be done inside resolvers, technically there's nothing stopping somebody from making <code>Query</code> fields act as <code>Mutation</code>s, taking inputs and executing state-changing logic.</p>
<p>In practice, such queries break the contract with client libraries such as Apollo-Client that do client-side caching and state management, resulting in non-responsive controls or inaccurate information being displayed in the UI as the library displays cached data before redrawing it to display an actual response from the GraphQL.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="defining-mutations"></a><a href="#defining-mutations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining mutations</h2>
<p>Let's define the basic schema that implements a simple authentication mechanism allowing the client to see if they are authenticated, and to log in and log out:</p>
<pre><code class="hljs css language-python">type_def = <span class="hljs-string">"""
    type Query {
        isAuthenticated: Boolean!
    }

    type Mutation {
        login(username: String!, password: String!): Boolean!
        logout: Boolean!
    }
"""</span>
</code></pre>
<p>In this example we have the following elements:</p>
<ul>
<li><code>Query</code> type with single field: a boolean for checking if we are authenticated or not. It may appear superficial for the sake of this example, <em>but Ariadne requires</em> that your GraphQL API always defines a <code>Query</code> type.</li>
<li><code>Mutation</code> type with two mutations:
<ul>
<li><code>login</code> mutation that requires username and password strings and returns a boolean indicating status.</li>
<li><code>logout</code> that takes no arguments and just returns status.</li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="writing-resolvers"></a><a href="#writing-resolvers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Writing resolvers</h2>
<p>Mutation resolvers are no different than resolvers used by other types. They are functions that take <code>parent</code> and <code>info</code> arguments, as well as any mutation's arguments as keyword arguments. They then return data that should be sent to the client as a query result:</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resolve_login</span><span class="hljs-params">(_, info, username, password)</span>:</span>
    request = info.context[<span class="hljs-string">"request"</span>]
    user = auth.authenticate(username, password)
    <span class="hljs-keyword">if</span> user:
        auth.login(request, user)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resolve_logout</span><span class="hljs-params">(_, info)</span>:</span>
    request = info.context[<span class="hljs-string">"request"</span>]
    <span class="hljs-keyword">if</span> request.user.is_authenticated:
        auth.logout(request)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</code></pre>
<p>You can map resolvers to mutations using a <code>MutationType</code> object:</p>
<pre><code class="hljs css language-python"><span class="hljs-keyword">from</span> ariadne <span class="hljs-keyword">import</span> MutationType
<span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> auth_mutations

mutation = MutationType()
mutation.set_field(<span class="hljs-string">"login"</span>, auth_mutations.resolve_login)
mutation.set_field(<span class="hljs-string">"logout"</span>, auth_mutations.resolve_logout)
</code></pre>
<blockquote>
<p><code>MutationType()</code> is just a shortcut for <code>ObjectType(&quot;Mutation&quot;)</code>.</p>
</blockquote>
<p><code>MutationType</code> objects include a <code>field()</code> decorator for mapping resolvers to mutations:</p>
<pre><code class="hljs css language-python">mutation = MutationType()

<span class="hljs-meta">@mutation.field("logout")</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resolve_logout</span><span class="hljs-params">(_, info)</span>:</span>
    ...
</code></pre>
<blockquote>
<p><strong>Binding Mutation Resolvers</strong></p>
<p>Recall that all resolvers need to be bound to their respective fields in the schema via the <code>make_executable_schema</code> call. If you're following along from the introduction that call will look similar to the following:</p>
<pre><code class="hljs css language-python">make_executable_schema(type_defs, [query, mutations])
</code></pre>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="mutation-payloads"></a><a href="#mutation-payloads" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutation payloads</h2>
<p>The <code>login</code> and <code>logout</code> mutations introduced earlier in this guide work, but give very limited feedback to the client: they return either <code>False</code> or <code>True</code>.  The application could use additional information like an error message that could be displayed in the interface if the mutation request fails, or a user state updated after a mutation completed.</p>
<p>In GraphQL this is achieved by making mutations return special <em>payload</em> types containing additional information about the result, such as errors or current object state:</p>
<pre><code class="hljs css language-python">type_def = <span class="hljs-string">"""
    type Mutation {
        login(username: String!, password: String!): LoginPayload
    }

    type LoginPayload {
        status: Boolean!
        error: Error
        user: User
    }
"""</span>
</code></pre>
<p>The above mutation will return a special type containing information about the mutation's status, as well as either an <code>Error</code> message or a logged in <code>User</code>. In Python this payload can be represented as a simple <code>dict</code>:</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resolve_login</span><span class="hljs-params">(_, info, username, password)</span>:</span>
    request = info.context[<span class="hljs-string">"request"</span>]
    user = auth.authenticate(username, password)
    <span class="hljs-keyword">if</span> user:
        auth.login(request, user)
        <span class="hljs-keyword">return</span> {<span class="hljs-string">"status"</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">"user"</span>: user}
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"status"</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">"error"</span>: <span class="hljs-string">"Invalid username or password"</span>}
</code></pre>
<p>Let's take one more look at the payload's fields:</p>
<ul>
<li><code>status</code> makes it easier for the frontend logic to check if mutation succeeded or not.</li>
<li><code>error</code> contains an error message returned by mutation or <code>null</code>. Errors can be simple strings, or more complex types that contain additional information for use by the client.</li>
</ul>
<p><code>user</code> field is especially noteworthy. Modern GraphQL client libraries like <a href="https://www.apollographql.com/docs/react/">Apollo Client</a> implement automatic caching and state management, using GraphQL types to track and automatically update stored object data whenever a new one is returned from the API.</p>
<p>Consider a mutation that changes a user's username and its payload:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">type</span> <span class="token class-name">Mutation</span> <span class="token punctuation">{</span>
    <span class="token attr-name">updateUsername</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> ID<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token attr-name">username</span><span class="token punctuation">:</span> String<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> userMutationPayload
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">UsernameMutationPayload</span> <span class="token punctuation">{</span>
    <span class="token attr-name">status</span><span class="token punctuation">:</span> Boolean<span class="token operator">!</span>
    <span class="token attr-name">error</span><span class="token punctuation">:</span> Error
    <span class="token attr-name">user</span><span class="token punctuation">:</span> User
<span class="token punctuation">}</span>
</code></pre>
<p>Our client code may first perform an <em>optimistic update</em> before the API executes a mutation and returns a response to client. This optimistic update will cause an immediate update of the application interface, making it appear fast and responsive to the user. When the mutation eventually completes a moment later and returns an updated <code>user</code> one of two things will happen:</p>
<p>If the mutation succeeded, the user doesn't see another UI update because the new data returned by the mutation was the same as the one set by the optimistic update. If the mutation asked for additional user fields that are dependant on username but weren't set optimistically (like link or user name changes history), those will be updated too.</p>
<p>If the mutation failed, changes performed by an optimistic update are overwritten by valid user state that contains the pre-changed username. The client then uses the <code>error</code> field to display an error message in the interface.</p>
<p>For the above reasons it is considered a good design for mutations to return an updated object whenever possible.</p>
<blockquote>
<p>There is no requirement for every mutation to have its own <code>Payload</code> type. <code>login</code> and <code>logout</code> mutations can both define <code>LoginPayload</code> as their return type. It is up to the developer to decide how generic or specific mutation payloads should be.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="inputs"></a><a href="#inputs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Inputs</h2>
<p>Let's consider the following type:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">type</span> <span class="token class-name">Discussion</span> <span class="token punctuation">{</span>
    <span class="token attr-name">category</span><span class="token punctuation">:</span> Category<span class="token operator">!</span>
    <span class="token attr-name">poster</span><span class="token punctuation">:</span> User
    <span class="token attr-name">postedOn</span><span class="token punctuation">:</span> Date<span class="token operator">!</span>
    <span class="token attr-name">title</span><span class="token punctuation">:</span> String<span class="token operator">!</span>
    <span class="token attr-name">isAnnouncement</span><span class="token punctuation">:</span> Boolean<span class="token operator">!</span>
    <span class="token attr-name">isClosed</span><span class="token punctuation">:</span> Boolean<span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Imagine a mutation for creating <code>Discussion</code>s that takes category, poster, title, announcement and closed states as inputs, and creates a new <code>Discussion</code> in the database. Looking at the previous example, we may want to define it like this:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">type</span> <span class="token class-name">Mutation</span> <span class="token punctuation">{</span>
    <span class="token attr-name">createDiscussion</span><span class="token punctuation">(</span>
        <span class="token attr-name">category</span><span class="token punctuation">:</span> ID<span class="token operator">!</span><span class="token punctuation">,</span>
        <span class="token attr-name">title</span><span class="token punctuation">:</span> String<span class="token operator">!</span><span class="token punctuation">,</span>
        <span class="token attr-name">isAnnouncement</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">,</span>
        <span class="token attr-name">isClosed</span><span class="token punctuation">:</span> Boolean
    <span class="token punctuation">)</span><span class="token punctuation">:</span> DiscussionPayload
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">DiscussionPayload</span> <span class="token punctuation">{</span>
    <span class="token attr-name">status</span><span class="token punctuation">:</span> Boolean<span class="token operator">!</span>
    <span class="token attr-name">error</span><span class="token punctuation">:</span> Error
    <span class="token attr-name">discussion</span><span class="token punctuation">:</span> Discussion
<span class="token punctuation">}</span>
</code></pre>
<p>Our mutation takes only four arguments, but it is already too unwieldy to work with. Imagine adding another one or two arguments to it in future - it's going to explode!</p>
<p>GraphQL provides a better way for solving this problem: <code>input</code> allows us to move arguments into a dedicated type:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">type</span> <span class="token class-name">Mutation</span> <span class="token punctuation">{</span>
    <span class="token attr-name">createDiscussion</span><span class="token punctuation">(</span><span class="token attr-name">input</span><span class="token punctuation">:</span> DiscussionInput<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> DiscussionPayload
<span class="token punctuation">}</span>

<span class="token keyword">input</span> DiscussionInput <span class="token punctuation">{</span>
    <span class="token attr-name">category</span><span class="token punctuation">:</span> ID<span class="token operator">!</span>
    <span class="token attr-name">title</span><span class="token punctuation">:</span> String<span class="token operator">!</span><span class="token punctuation">,</span>
    <span class="token attr-name">isAnnouncement</span><span class="token punctuation">:</span> Boolean
    <span class="token attr-name">isClosed</span><span class="token punctuation">:</span> Boolean
<span class="token punctuation">}</span>
</code></pre>
<p>Now, when a client wants to create a new discussion, it needs to provide an <code>input</code> object that matches the <code>DiscussionInput</code> definition. This input will then be validated and passed to the mutation's resolver as a <code>dict</code> available under the <code>input</code> keyword argument:</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resolve_create_discussion</span><span class="hljs-params">(_, info, input)</span>:</span>
    clean_input = {
        <span class="hljs-string">"category"</span>: input[<span class="hljs-string">"category"</span>],
        <span class="hljs-string">"title"</span>: input[<span class="hljs-string">"title"</span>],
        <span class="hljs-string">"is_announcement"</span>: input.get(<span class="hljs-string">"isAnnouncement"</span>),
        <span class="hljs-string">"is_closed"</span>: input.get(<span class="hljs-string">"isClosed"</span>),
    }

    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"status"</span>: <span class="hljs-literal">True</span>,
            <span class="hljs-string">"discussion"</span>: create_new_discussion(info.context, clean_input),
        }
    <span class="hljs-keyword">except</span> ValidationError <span class="hljs-keyword">as</span> err:
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"status"</span>: <span class="hljs-literal">False</span>,
            <span class="hljs-string">"error"</span>: err,
        }
</code></pre>
<p>Another advantage of <code>input</code> types is that they are reusable. If we later decide to implement another mutation for updating the <code>Discussion</code>, we can do it like this:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">type</span> <span class="token class-name">Mutation</span> <span class="token punctuation">{</span>
    <span class="token attr-name">createDiscussion</span><span class="token punctuation">(</span><span class="token attr-name">input</span><span class="token punctuation">:</span> DiscussionInput<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> DiscussionPayload
    <span class="token attr-name">updateDiscussion</span><span class="token punctuation">(</span><span class="token attr-name">discussion</span><span class="token punctuation">:</span> ID<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token attr-name">input</span><span class="token punctuation">:</span> DiscussionInput<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> DiscussionPayload
<span class="token punctuation">}</span>

<span class="token keyword">input</span> DiscussionInput <span class="token punctuation">{</span>
    <span class="token attr-name">category</span><span class="token punctuation">:</span> ID<span class="token operator">!</span>
    <span class="token attr-name">title</span><span class="token punctuation">:</span> String<span class="token operator">!</span>
    <span class="token attr-name">isAnnouncement</span><span class="token punctuation">:</span> Boolean
    <span class="token attr-name">isClosed</span><span class="token punctuation">:</span> Boolean
<span class="token punctuation">}</span>
</code></pre>
<p>Our <code>updateDiscussion</code> mutation will now accept two arguments: <code>discussion</code> and <code>input</code>:</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resolve_update_discussion</span><span class="hljs-params">(_, info, discussion, input)</span>:</span>
    clean_input = {
        <span class="hljs-string">"category"</span>: input[<span class="hljs-string">"category"</span>],
        <span class="hljs-string">"title"</span>: input[<span class="hljs-string">"title"</span>],
        <span class="hljs-string">"is_announcement"</span>: input.get(<span class="hljs-string">"isAnnouncement"</span>),
        <span class="hljs-string">"is_closed"</span>: input.get(<span class="hljs-string">"isClosed"</span>),
    }

    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"status"</span>: <span class="hljs-literal">True</span>,
            <span class="hljs-string">"discussion"</span>: update_discussion(info.context, discussion, clean_input),
        }
    <span class="hljs-keyword">except</span> ValidationError <span class="hljs-keyword">as</span> err:
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"status"</span>: <span class="hljs-literal">False</span>,
            <span class="hljs-string">"error"</span>: err,
        }
</code></pre>
<p>You may wonder why you would want to use <code>input</code> instead of reusing an already-defined type. This is because input types provide some guarantees that regular objects don't: they are serializable, and they don't implement interfaces or unions. However, input fields are not limited to scalars. You can create fields that are lists, or even reference other inputs:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">input</span> PollInput <span class="token punctuation">{</span>
    <span class="token attr-name">question</span><span class="token punctuation">:</span> String<span class="token operator">!</span><span class="token punctuation">,</span>
    <span class="token attr-name">options</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>PollOptionInput<span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> PollOptionInput <span class="token punctuation">{</span>
    <span class="token attr-name">label</span><span class="token punctuation">:</span> String<span class="token operator">!</span>
    <span class="token attr-name">color</span><span class="token punctuation">:</span> String<span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Lastly, take note that inputs are not specific to mutations. You can create inputs to implement complex filtering in your <code>Query</code> fields.</p>
<blockquote>
<p><strong>Note:</strong> you can decorate your resolvers with <a href="/docs/0.12.0/api-reference#convert_kwargs_to_snake_case"><code>convert_kwargs_to_snake_case</code></a> to convert arguments and inputs names from <code>camelCase</code> to <code>snake_case</code>.</p>
</blockquote>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/0.12.0/resolvers"><span class="arrow-prev">← </span><span>Resolvers</span></a><a class="docs-next button" href="/docs/0.12.0/error-messaging"><span>Error messaging</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#defining-mutations">Defining mutations</a></li><li><a href="#writing-resolvers">Writing resolvers</a></li><li><a href="#mutation-payloads">Mutation payloads</a></li><li><a href="#inputs">Inputs</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/icon.png" alt="Ariadne" height="107" width="128"/></a><div class="footerNavSpacer"></div><div class="footerNavTwoColumn"><h5>Documentation</h5><a href="/docs/intro.html">Introduction</a><a href="/docs/resolvers.html">Resolvers</a><a href="/docs/mutations.html">Mutations</a><a href="/docs/subscriptions.html">Subscriptions</a><a href="/docs/django-integration.html">Django integration</a><a href="/docs/flask-integration.html">Flask integration</a><a href="/docs/starlette-integration.html">Starlette integration</a><a href="/docs/other-integrations.html">Other integrations</a><a href="/docs/api-reference.html">API Reference</a><a href="/docs/logo.html">Logo</a></div><div><h5>Community</h5><a href="https://github.com/mirumee/ariadne/discussions/">Discuss</a><a href="https://github.com/mirumee/ariadne">GitHub</a><a class="github-button" href="https://github.com/mirumee/ariadne" data-icon="octicon-star" data-count-href="/mirumee/ariadne/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright"><a href="https://mirumee.com">Copyright © 2025 Mirumee Software</a><a href="https://mirumee.com">Ariadne is crafted with love by<img src="/img/mirumee.png" alt="Mirumee"/></a></section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '507581234da84aebc8fe9918f530b714',
                indexName: 'ariadnegraphql',
                inputSelector: '#search_input_react'
              });
            </script></body></html>