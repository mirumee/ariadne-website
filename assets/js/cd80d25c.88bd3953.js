"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["51333"],{352:function(e,n,s){s.r(n),s.d(n,{frontMatter:()=>a,toc:()=>l,default:()=>h,metadata:()=>i,assets:()=>c,contentTitle:()=>t});var i=JSON.parse('{"id":"Docs/sync-subscriptions","title":"Synchronous Generator Subscriptions","description":"Ariadne supports both asynchronous and synchronous generators as subscription sources. Synchronous generators are automatically executed in worker threads to avoid blocking the event loop, making it easy to integrate blocking I/O operations (like database queries, file operations, or third-party APIs) into GraphQL subscriptions.","source":"@site/../ariadne/docs/01-Docs/23-sync-subscriptions.md","sourceDirName":"01-Docs","slug":"/Docs/sync-subscriptions","permalink":"/server/next/Docs/sync-subscriptions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":23,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Apollo Federation","permalink":"/server/next/Docs/apollo-federation"},"next":{"title":"OpenTelemetry","permalink":"/server/next/Monitoring/open-telemetry"}}'),r=s(74848),o=s(84429);let a={},t="Synchronous Generator Subscriptions",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Quick Start",id:"quick-start",level:2},{value:"Basic Synchronous Generator",id:"basic-synchronous-generator",level:3},{value:"Comparison: Async vs Sync",id:"comparison-async-vs-sync",level:3},{value:"How It Works",id:"how-it-works",level:2},{value:"Automatic Detection",id:"automatic-detection",level:3},{value:"Thread Offloading",id:"thread-offloading",level:3},{value:"Flow Diagram",id:"flow-diagram",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"1. Legacy Database Integrations",id:"1-legacy-database-integrations",level:3},{value:"2. File System Monitoring",id:"2-file-system-monitoring",level:3},{value:"3. Third-Party API Polling",id:"3-third-party-api-polling",level:3},{value:"4. Message Queue Consumers",id:"4-message-queue-consumers",level:3},{value:"Examples",id:"examples",level:2},{value:"Example 1: Database Query Stream",id:"example-1-database-query-stream",level:3},{value:"Example 2: Time-Based Events",id:"example-2-time-based-events",level:3},{value:"Example 3: Mixed Sync/Async Sources",id:"example-3-mixed-syncasync-sources",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Resource Cleanup",id:"1-resource-cleanup",level:3},{value:"2. Error Handling",id:"2-error-handling",level:3},{value:"3. Generator Exhaustion",id:"3-generator-exhaustion",level:3},{value:"4. Performance Considerations",id:"4-performance-considerations",level:3},{value:"5. Scalability Considerations",id:"5-scalability-considerations",level:3},{value:"Thread Pool Limitations",id:"thread-pool-limitations",level:4},{value:"Memory Overhead",id:"memory-overhead",level:4},{value:"Performance Overhead",id:"performance-overhead",level:4},{value:"Recommendations",id:"recommendations",level:4},{value:"When to Use Each Approach",id:"when-to-use-each-approach",level:4},{value:"6. Testing",id:"6-testing",level:3},{value:"Technical Details",id:"technical-details",level:2},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Cleanup Mechanism",id:"cleanup-mechanism",level:3},{value:"Exception Propagation",id:"exception-propagation",level:3},{value:"Implementation Details",id:"implementation-details",level:3},{value:"Compatibility",id:"compatibility",level:3},{value:"Migration Guide",id:"migration-guide",level:2},{value:"From Async to Sync (when needed)",id:"from-async-to-sync-when-needed",level:3},{value:"When to Use Each",id:"when-to-use-each",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Generator Not Closing",id:"generator-not-closing",level:3},{value:"Thread Pool Exhaustion",id:"thread-pool-exhaustion",level:3},{value:"Performance Issues",id:"performance-issues",level:3},{value:"Summary",id:"summary",level:2}];function d(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"synchronous-generator-subscriptions",children:"Synchronous Generator Subscriptions"})}),"\n",(0,r.jsxs)(n.p,{children:["Ariadne supports both ",(0,r.jsx)(n.strong,{children:"asynchronous"})," and ",(0,r.jsx)(n.strong,{children:"synchronous"})," generators as subscription sources. Synchronous generators are automatically executed in worker threads to avoid blocking the event loop, making it easy to integrate blocking I/O operations (like database queries, file operations, or third-party APIs) into GraphQL subscriptions."]}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#quick-start",children:"Quick Start"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#how-it-works",children:"How It Works"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#use-cases",children:"Use Cases"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#examples",children:"Examples"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#technical-details",children:"Technical Details"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,r.jsx)(n.h3,{id:"basic-synchronous-generator",children:"Basic Synchronous Generator"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from ariadne import SubscriptionType, make_executable_schema\n\nsubscription = SubscriptionType()\n\n@subscription.source("messages")\ndef message_source(*_, channel: str = "default"):\n    # This is a synchronous generator - no async/await needed!\n    for message in get_messages_from_database(channel):  # Blocking DB call\n        yield {"text": message.text, "author": message.author}\n\nschema = make_executable_schema(\n    """\n    type Query {\n        _: Boolean\n    }\n    type Subscription {\n        messages(channel: String): Message!\n    }\n    type Message {\n        text: String!\n        author: String!\n    }\n    """,\n    subscription,\n)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"comparison-async-vs-sync",children:"Comparison: Async vs Sync"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Async Generator (existing approach):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@subscription.source("messages")\nasync def message_source(*_, channel: str = "default"):\n    async for message in async_db_client.stream_messages(channel):\n        yield {"text": message.text, "author": message.author}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Sync Generator (new approach):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@subscription.source("messages")\ndef message_source(*_, channel: str = "default"):\n    for message in sync_db_client.get_messages(channel):  # Blocking call\n        yield {"text": message.text, "author": message.author}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Both work identically from the client's perspective!"}),"\n",(0,r.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,r.jsx)(n.h3,{id:"automatic-detection",children:"Automatic Detection"}),"\n",(0,r.jsx)(n.p,{children:"When you register a subscription source, Ariadne automatically detects whether it's synchronous or asynchronous:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Async generators"}),": Functions defined with ",(0,r.jsx)(n.code,{children:"async def"})," that use ",(0,r.jsx)(n.code,{children:"yield"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Synchronous generators"}),": Functions defined with ",(0,r.jsx)(n.code,{children:"def"})," that use ",(0,r.jsx)(n.code,{children:"yield"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"thread-offloading",children:"Thread Offloading"}),"\n",(0,r.jsx)(n.p,{children:"Synchronous generators are automatically wrapped in an async generator that:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Creates the sync generator"})," when the subscription starts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Executes ",(0,r.jsx)(n.code,{children:"next(gen)"})," calls in a worker thread"]})," using ",(0,r.jsx)(n.code,{children:"anyio.to_thread.run_sync()"})," (or ",(0,r.jsx)(n.code,{children:"asyncio.to_thread()"})," as fallback)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Yields values"})," from the sync generator to the async stream"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handles cleanup"})," by calling ",(0,r.jsx)(n.code,{children:"gen.close()"})," when the subscription ends or client disconnects"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"flow-diagram",children:"Flow Diagram"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Client Request\n    \u2193\nGraphQL Subscription Execution\n    \u2193\nIs source sync or async?\n    \u251C\u2500\u2192 Async: Execute directly\n    \u2514\u2500\u2192 Sync: Wrap in async generator\n              \u2193\n         Worker Thread Pool\n              \u2193\n         Execute next(sync_gen)\n              \u2193\n         Yield value to async stream\n              \u2193\n         Client receives update\n"})}),"\n",(0,r.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,r.jsx)(n.h3,{id:"1-legacy-database-integrations",children:"1. Legacy Database Integrations"}),"\n",(0,r.jsxs)(n.p,{children:["When working with synchronous database libraries (like ",(0,r.jsx)(n.code,{children:"psycopg2"}),", ",(0,r.jsx)(n.code,{children:"pymongo"}),", or Django ORM):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from django.db import models\n\n@subscription.source("posts")\ndef post_updates(*_, category: str = None):\n    # Django ORM queries are synchronous\n    queryset = models.Post.objects.filter(category=category)\n    \n    for post in queryset.iterator():\n        yield {\n            "id": post.id,\n            "title": post.title,\n            "content": post.content,\n        }\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-file-system-monitoring",children:"2. File System Monitoring"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import os\nimport time\n\n@subscription.source("fileChanges")\ndef watch_file(*_, filepath: str):\n    last_modified = 0\n    \n    while True:\n        try:\n            current_modified = os.path.getmtime(filepath)\n            if current_modified > last_modified:\n                last_modified = current_modified\n                with open(filepath, \'r\') as f:\n                    yield {"content": f.read(), "modified": current_modified}\n            time.sleep(1)  # Blocking sleep is OK!\n        except FileNotFoundError:\n            break\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-third-party-api-polling",children:"3. Third-Party API Polling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import requests\n\n@subscription.source("apiUpdates")\ndef poll_api(*_, endpoint: str):\n    while True:\n        response = requests.get(endpoint)  # Blocking HTTP call\n        yield {"data": response.json(), "status": response.status_code}\n        time.sleep(5)  # Poll every 5 seconds\n'})}),"\n",(0,r.jsx)(n.h3,{id:"4-message-queue-consumers",children:"4. Message Queue Consumers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import pika  # RabbitMQ synchronous client\n\n@subscription.source("queueMessages")\ndef consume_queue(*_, queue_name: str):\n    connection = pika.BlockingConnection(pika.ConnectionParameters(\'localhost\'))\n    channel = connection.channel()\n    \n    try:\n        for method, properties, body in channel.consume(queue_name):\n            if body:\n                yield {"message": body.decode(), "routing_key": method.routing_key}\n                channel.basic_ack(method.delivery_tag)\n    finally:\n        connection.close()  # Cleanup happens automatically!\n'})}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.h3,{id:"example-1-database-query-stream",children:"Example 1: Database Query Stream"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from ariadne import SubscriptionType, make_executable_schema\nimport sqlite3\n\nsubscription = SubscriptionType()\n\n@subscription.source("users")\ndef user_stream(*_, active: bool = True):\n    conn = sqlite3.connect(\'users.db\')\n    cursor = conn.cursor()\n    \n    try:\n        query = "SELECT id, name, email FROM users WHERE active = ?"\n        cursor.execute(query, (active,))\n        \n        for row in cursor:\n            yield {\n                "id": row[0],\n                "name": row[1],\n                "email": row[2],\n            }\n    finally:\n        conn.close()  # Cleanup in finally block\n\n@subscription.field("users")\ndef resolve_user(message, *_):\n    return message  # Pass through the yielded data\n\nschema = make_executable_schema(\n    """\n    type Query {\n        _: Boolean\n    }\n    type Subscription {\n        users(active: Boolean): User!\n    }\n    type User {\n        id: ID!\n        name: String!\n        email: String!\n    }\n    """,\n    subscription,\n)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"example-2-time-based-events",children:"Example 2: Time-Based Events"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import time\nfrom datetime import datetime\n\n@subscription.source("timeUpdates")\ndef time_stream(*_, interval: int = 1):\n    """Emit current time at specified intervals."""\n    while True:\n        yield {\n            "timestamp": datetime.now().isoformat(),\n            "unix_time": int(time.time()),\n        }\n        time.sleep(interval)  # Blocking sleep\n\n@subscription.field("timeUpdates")\ndef resolve_time(message, *_):\n    return message\n'})}),"\n",(0,r.jsx)(n.h3,{id:"example-3-mixed-syncasync-sources",children:"Example 3: Mixed Sync/Async Sources"}),"\n",(0,r.jsx)(n.p,{children:"You can mix synchronous and asynchronous generators in the same subscription type:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'subscription = SubscriptionType()\n\n# Sync source for blocking operations\n@subscription.source("syncData")\ndef sync_source(*_):\n    # Blocking I/O\n    data = requests.get("https://api.example.com/data").json()\n    yield data\n\n# Async source for async operations\n@subscription.source("asyncData")\nasync def async_source(*_):\n    # Non-blocking I/O\n    async with aiohttp.ClientSession() as session:\n        async with session.get("https://api.example.com/data") as resp:\n            data = await resp.json()\n            yield data\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-resource-cleanup",children:"1. Resource Cleanup"}),"\n",(0,r.jsxs)(n.p,{children:["Always use ",(0,r.jsx)(n.code,{children:"try...finally"})," blocks for cleanup in synchronous generators:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@subscription.source("data")\ndef data_source(*_):\n    connection = create_connection()\n    try:\n        for item in connection.stream():\n            yield item\n    finally:\n        connection.close()  # Always cleanup\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Ariadne automatically calls ",(0,r.jsx)(n.code,{children:"gen.close()"})," when the subscription ends, which triggers the ",(0,r.jsx)(n.code,{children:"finally"})," block."]}),"\n",(0,r.jsx)(n.h3,{id:"2-error-handling",children:"2. Error Handling"}),"\n",(0,r.jsx)(n.p,{children:"Handle exceptions appropriately:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@subscription.source("data")\ndef data_source(*_):\n    try:\n        for item in get_data():\n            yield item\n    except ConnectionError as e:\n        # Log error, yield error message, or re-raise\n        yield {"error": str(e)}\n        raise  # Re-raise to propagate to GraphQL error handling\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-generator-exhaustion",children:"3. Generator Exhaustion"}),"\n",(0,r.jsx)(n.p,{children:"Synchronous generators can exhaust naturally:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@subscription.source("limited")\ndef limited_source(*_, count: int = 10):\n    for i in range(count):\n        yield {"value": i}\n    # Generator ends naturally - no need to raise StopIteration\n'})}),"\n",(0,r.jsx)(n.h3,{id:"4-performance-considerations",children:"4. Performance Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use sync generators"})," for: Legacy libraries, blocking I/O, CPU-bound operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use async generators"})," for: Modern async libraries, high-concurrency scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread pool"}),": Sync generators share a thread pool, so avoid creating too many concurrent subscriptions with blocking operations"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"5-scalability-considerations",children:"5. Scalability Considerations"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Important"}),": Synchronous generators are implemented using thread-based execution (",(0,r.jsx)(n.code,{children:"anyio.to_thread.run_sync"})," or ",(0,r.jsx)(n.code,{children:"asyncio.to_thread"}),"). This approach has scalability implications that should be understood:"]}),"\n",(0,r.jsx)(n.h4,{id:"thread-pool-limitations",children:"Thread Pool Limitations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limited concurrent subscriptions"}),": The number of concurrent synchronous subscriptions is bounded by the thread pool size (typically 32-40 threads by default, depending on Python version and runtime)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread pool exhaustion"}),": If you exceed the thread pool capacity, new subscription requests will wait for available threads, potentially causing delays or timeouts"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"memory-overhead",children:"Memory Overhead"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Higher memory usage"}),": Each synchronous subscription consumes:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Thread stack space (~8MB per thread on most systems)"}),"\n",(0,r.jsx)(n.li,{children:"Generator state and context"}),"\n",(0,r.jsx)(n.li,{children:"Any resources held by the synchronous generator (database connections, file handles, etc.)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory scaling"}),": Memory usage scales linearly with the number of concurrent sync subscriptions, unlike async generators which share the event loop"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"performance-overhead",children:"Performance Overhead"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread context switching"}),": Each ",(0,r.jsx)(n.code,{children:"next()"})," call requires:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Switching from async context to thread context"}),"\n",(0,r.jsx)(n.li,{children:"Executing in a worker thread"}),"\n",(0,r.jsx)(n.li,{children:"Switching back to async context"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Overhead per yield"}),": This context switching adds latency compared to async generators, which execute directly in the event loop"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Blocking operations"}),": While blocking operations don't block the event loop, they still consume thread resources and can impact overall throughput"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"recommendations",children:"Recommendations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"For high-concurrency scenarios"}),": Prefer async generators when possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"For legacy integrations"}),": Sync generators are acceptable for occasional or low-volume subscriptions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor thread pool usage"}),": Watch for thread pool exhaustion warnings in production"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consider connection pooling"}),": If using sync generators with databases, use connection pooling to limit resource consumption"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Batch operations"}),": When possible, batch operations in sync generators to reduce the number of thread switches"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"when-to-use-each-approach",children:"When to Use Each Approach"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Async Generators when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You need high concurrency (hundreds or thousands of concurrent subscriptions)"}),"\n",(0,r.jsx)(n.li,{children:"You have async libraries available (aiohttp, asyncpg, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Low latency is critical"}),"\n",(0,r.jsx)(n.li,{children:"You're building new features from scratch"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Sync Generators when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You're integrating with legacy/synchronous libraries"}),"\n",(0,r.jsx)(n.li,{children:"You have a small number of concurrent subscriptions (< 50)"}),"\n",(0,r.jsx)(n.li,{children:"Blocking I/O is unavoidable"}),"\n",(0,r.jsx)(n.li,{children:"You're migrating existing sync code to GraphQL subscriptions"}),"\n",(0,r.jsx)(n.li,{children:"The convenience of sync code outweighs scalability concerns"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"6-testing",children:"6. Testing"}),"\n",(0,r.jsx)(n.p,{children:"Test synchronous generators like any other subscription:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import pytest\nfrom ariadne.graphql import subscribe\n\n@pytest.mark.asyncio\nasync def test_sync_subscription(schema):\n    success, result = await subscribe(\n        schema, {"query": "subscription { messages { text } }"}\n    )\n    assert success\n    \n    # Consume the async generator\n    item = await result.__anext__()\n    assert item.data["messages"]["text"] == "Hello"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"technical-details",children:"Technical Details"}),"\n",(0,r.jsx)(n.h3,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each synchronous generator runs in its own worker thread"}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"next()"})," calls are serialized per generator (one at a time)"]}),"\n",(0,r.jsx)(n.li,{children:"Multiple subscriptions can run concurrently in different threads"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"cleanup-mechanism",children:"Cleanup Mechanism"}),"\n",(0,r.jsx)(n.p,{children:"When a subscription ends (client disconnects, generator exhausts, or error occurs):"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["The async wrapper's ",(0,r.jsx)(n.code,{children:"finally"})," block executes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"gen.close()"})," is called on the synchronous generator in a worker thread"]}),"\n",(0,r.jsxs)(n.li,{children:["This triggers the generator's ",(0,r.jsx)(n.code,{children:"finally"})," block (if present)"]}),"\n",(0,r.jsx)(n.li,{children:"Resources are cleaned up properly"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"exception-propagation",children:"Exception Propagation"}),"\n",(0,r.jsx)(n.p,{children:"Exceptions raised in synchronous generators:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Are caught by the thread executor"}),"\n",(0,r.jsx)(n.li,{children:"Propagated back to the async wrapper"}),"\n",(0,r.jsx)(n.li,{children:"Raised in the async generator"}),"\n",(0,r.jsx)(n.li,{children:"Handled by GraphQL's error reporting mechanism"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,r.jsx)(n.p,{children:"The wrapping logic:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Simplified version of what happens internally\nasync def async_wrapper(*args, **kwargs):\n    sync_gen = sync_generator_function(*args, **kwargs)\n    \n    try:\n        while True:\n            try:\n                # Run next() in worker thread\n                value = await to_thread.run_sync(next, sync_gen)\n                yield value\n            except StopIteration:\n                break\n    finally:\n        # Cleanup: close the sync generator\n        if hasattr(sync_gen, "close"):\n            await to_thread.run_sync(sync_gen.close)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"compatibility",children:"Compatibility"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Python"}),": 3.10+ (uses ",(0,r.jsx)(n.code,{children:"asyncio.to_thread"})," or ",(0,r.jsx)(n.code,{children:"anyio.to_thread.run_sync"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Frameworks"}),": Works with Starlette, FastAPI, and any ASGI-compatible framework"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backward Compatible"}),": Existing async generators continue to work unchanged"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"migration-guide",children:"Migration Guide"}),"\n",(0,r.jsx)(n.h3,{id:"from-async-to-sync-when-needed",children:"From Async to Sync (when needed)"}),"\n",(0,r.jsx)(n.p,{children:"If you have blocking I/O and want to simplify:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Before:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@subscription.source("data")\nasync def data_source(*_):\n    # Had to wrap sync calls in run_in_executor\n    loop = asyncio.get_event_loop()\n    data = await loop.run_in_executor(None, blocking_function)\n    yield data\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"After:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@subscription.source("data")\ndef data_source(*_):\n    # Direct blocking call - Ariadne handles threading\n    data = blocking_function()\n    yield data\n'})}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-each",children:"When to Use Each"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Async Generators when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You have async libraries available (aiohttp, asyncpg, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"You need high concurrency"}),"\n",(0,r.jsx)(n.li,{children:"You're already in an async context"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Sync Generators when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You have legacy/synchronous libraries"}),"\n",(0,r.jsx)(n.li,{children:"Blocking I/O is unavoidable"}),"\n",(0,r.jsx)(n.li,{children:"You want simpler code without async/await complexity"}),"\n",(0,r.jsx)(n.li,{children:"You're migrating existing sync code to GraphQL subscriptions"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"generator-not-closing",children:"Generator Not Closing"}),"\n",(0,r.jsx)(n.p,{children:"If your generator's cleanup code isn't running:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Ensure you're using ",(0,r.jsx)(n.code,{children:"try...finally"})," blocks"]}),"\n",(0,r.jsxs)(n.li,{children:["Check that ",(0,r.jsx)(n.code,{children:"gen.close()"})," is being called (Ariadne does this automatically)"]}),"\n",(0,r.jsx)(n.li,{children:"Verify the subscription is properly ending (not hanging)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"thread-pool-exhaustion",children:"Thread Pool Exhaustion"}),"\n",(0,r.jsx)(n.p,{children:"If you see thread pool errors:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reduce the number of concurrent sync subscriptions"}),"\n",(0,r.jsx)(n.li,{children:"Consider converting some to async generators"}),"\n",(0,r.jsx)(n.li,{children:"Increase thread pool size (framework-dependent)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance-issues",children:"Performance Issues"}),"\n",(0,r.jsx)(n.p,{children:"If sync subscriptions are slow:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Verify blocking operations are necessary"}),"\n",(0,r.jsx)(n.li,{children:"Consider caching or batching"}),"\n",(0,r.jsx)(n.li,{children:"Profile to identify bottlenecks"}),"\n",(0,r.jsx)(n.li,{children:"Consider async alternatives if available"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Synchronous generator subscriptions provide a simple way to integrate blocking I/O operations into GraphQL subscriptions without requiring async/await complexity. Ariadne automatically handles thread offloading, cleanup, and error propagation, making it easy to work with legacy libraries and blocking operations while maintaining the benefits of async GraphQL subscriptions."})]})}function h(e={}){let{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},84429:function(e,n,s){s.d(n,{R:()=>a,x:()=>t});var i=s(96540);let r={},o=i.createContext(r);function a(e){let n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);