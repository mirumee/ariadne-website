"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["2366"],{92918:function(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>o});var i=s(12541),a=s(74848),r=s(84429);let t={title:"Ariadne Codegen 0.7"},l,d={authorsImageUrls:[]},o=[{value:"Subscriptions",id:"subscriptions",level:2},{value:"Fragments",id:"fragments",level:2},{value:"Unions and Interfaces",id:"unions-and-interfaces",level:3},{value:"<code>ShorterResultsPlugin</code>",id:"shorterresultsplugin",level:2},{value:"Discriminated unions",id:"discriminated-unions",level:2},{value:"Leading underscores",id:"leading-underscores",level:2},{value:"Removal of <code>mixin</code> directive from operation sent to a server",id:"removal-of-mixin-directive-from-operation-sent-to-a-server",level:2},{value:"<code>process_schema</code> plugin hook",id:"process_schema-plugin-hook",level:2},{value:"Changelog",id:"changelog",level:2}];function c(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Ariadne Codegen 0.7 is now available!"}),"\n",(0,a.jsxs)(n.p,{children:["This release brings support for subscriptions, changes how fragments are represented in generated code, introduces the ",(0,a.jsx)(n.code,{children:"ShorterResultsPlugin"})," plugin developed by our amazing community, and more features and fixes."]}),"\n",(0,a.jsx)(n.h2,{id:"subscriptions",children:"Subscriptions"}),"\n",(0,a.jsxs)(n.p,{children:["Version ",(0,a.jsx)(n.code,{children:"0.7"})," introduces support for subscriptions. We generate them as async generators, which means that we don't support subscriptions when the generated client is not async (",(0,a.jsx)(n.code,{children:"async_client"})," is set to ",(0,a.jsx)(n.code,{children:"false"}),")."]}),"\n",(0,a.jsx)(n.p,{children:"For example, given the following operation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-gql",children:"subscription GetUsersCounter {\n  usersCounter\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Generated client will have following method:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:'    async def get_users_counter(self) -> AsyncIterator[GetUsersCounter]:\n        query = gql(\n            """\n            subscription GetUsersCounter {\n              usersCounter\n            }\n            """\n        )\n        variables: dict[str, object] = {}\n        async for data in self.execute_ws(query=query, variables=variables):\n            yield GetUsersCounter.parse_obj(data)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Our default async base client uses ",(0,a.jsx)(n.a,{href:"https://github.com/python-websockets/websockets",children:"websockets"})," package and implements ",(0,a.jsx)(n.a,{href:"https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md",children:"graphql-transport-ws"})," subprotocol."]}),"\n",(0,a.jsx)(n.p,{children:"Required dependencies can be installed with pip:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"$ pip install ariadne-codegen[subscriptions]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"fragments",children:"Fragments"}),"\n",(0,a.jsx)(n.p,{children:'In previous versions of Codegen fragments were "unpacked" in queries. For example, given the following operations:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-gql",children:"query GetA {\n  getTypeA {\n    ...FragmentA\n  }\n}\n\nquery ListA {\n  listTypeA {\n    ...FragmentA\n  }\n}\n\nfragment FragmentA on TypeA {\n  id\n  name\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Generated ",(0,a.jsx)(n.code,{children:"get_a.py"})," and ",(0,a.jsx)(n.code,{children:"list_a.py"})," files had types looking like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:'# get_a.py\n\nclass GetA(BaseModel):\n    get_type_a: "GetAGetTypeA" = Field(alias="GetTypeA")\n\n\nclass GetAGetTypeA(BaseModel):\n    id: str\n    name: str\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:'# list_a.py\n\nclass ListA(BaseModel):\n    list_type_a: List["ListAListTypeA"] = Field(alias="ListTypeA")\n\n\nclass ListAListTypeA(BaseModel):\n    id: str\n    name: str\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Both of these operations use the same ",(0,a.jsx)(n.code,{children:"FragmentA"})," to represent ",(0,a.jsx)(n.code,{children:"TypeA"}),", but generated models didn't reflect that."]}),"\n",(0,a.jsxs)(n.p,{children:["To make working with fragments easier, in Ariadne Codegen 0.7 we are changing this behavior. Instead of unpacking fragments, we generate separate models from them and use those as mixins. The above operation will now result in 3 files being generated: ",(0,a.jsx)(n.code,{children:"get_a.py"}),", ",(0,a.jsx)(n.code,{children:"list_a.py"}),", and ",(0,a.jsx)(n.code,{children:"fragments.py"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:'# get_a.py\n\nclass GetA(BaseModel):\n    get_type_a: "GetAGetTypeA" = Field(alias="GetTypeA")\n\n\nclass GetAGetTypeA(FragmentA):\n    pass\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:'# list_a.py\n\nclass ListA(BaseModel):\n    list_type_a: List["ListAListTypeA"] = Field(alias="ListTypeA")\n\n\nclass ListAListTypeA(FragmentA):\n    pass\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# fragments.py\n\nclass FragmentA(BaseModel):\n    id: str\n    name: str\n"})}),"\n",(0,a.jsxs)(n.p,{children:["With this change you can use fragments as reusable types in your Python logic using the client, eg. ",(0,a.jsx)(n.code,{children:"def process_a(a: FragmentA)..."}),". New ",(0,a.jsx)(n.code,{children:"fragments.py"})," consists of fragments collected from all parsed operations."]}),"\n",(0,a.jsx)(n.h3,{id:"unions-and-interfaces",children:"Unions and Interfaces"}),"\n",(0,a.jsxs)(n.p,{children:["There is an exception from new fragments behaviour. If a fragment represents ",(0,a.jsx)(n.code,{children:"Union"})," then we unpack it as before:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-gql",children:"query getAnimal {\n  animal {\n    ...AnimalData\n  }\n}\n\nfragment AnimalData on AnimalInterface {\n  name\n  ... on Dog {\n    dogField\n  }\n  ... on Cat {\n    catField\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"For the above fragment, this Python code will be generated:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:'class GetAnimal(BaseModel):\n    animal: Union[\n        "GetAnimalAnimalAnimalInterface", "GetAnimalAnimalDog", "GetAnimalAnimalCat"\n    ] = Field(discriminator="typename__")\n\n\nclass GetAnimalAnimalAnimalInterface(BaseModel):\n    typename__: Literal["AnimalInterface", "Fish"] = Field(alias="__typename")\n    name: str\n\n\nclass GetAnimalAnimalDog(BaseModel):\n    typename__: Literal["Dog"] = Field(alias="__typename")\n    name: str\n    dog_field: str = Field(alias="dogField")\n\n\nclass GetAnimalAnimalCat(BaseModel):\n    typename__: Literal["Cat"] = Field(alias="__typename")\n    name: str\n    cat_field: str = Field(alias="catField")\n'})}),"\n",(0,a.jsx)(n.h2,{id:"shorterresultsplugin",children:(0,a.jsx)(n.code,{children:"ShorterResultsPlugin"})}),"\n",(0,a.jsxs)(n.p,{children:["In version 0.7 we are including ",(0,a.jsx)(n.code,{children:"ShorterResultsPlugin"})," developed by our community. It can be used when operations have only one top-level field. For example, given the following operation:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-gql",children:"query GetUser($userId: ID!) {\n  user(id: $userId) {\n    id\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"From this operation, the generated method looks like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:'async def get_user(self, user_id: str) -> GetUser:\n    query = gql(\n        """\n        query GetUser($userId: ID!) {\n            user(id: $userId) {\n                id\n            }\n        }\n        """\n    )\n    variables: dict[str, object] = {"userId": user_id}\n    response = await self.execute(query=query, variables=variables)\n    data = self.get_data(response)\n    return GetUser.parse_obj(data)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["To get the value of ",(0,a.jsx)(n.code,{children:"user"}),", we need to always get it by attribute, eg. ",(0,a.jsx)(n.code,{children:'await get_user("1").user'}),". By using ",(0,a.jsx)(n.code,{children:"ShorterResultsPlugin"})," our ",(0,a.jsx)(n.code,{children:"get_user"})," returns the value of ",(0,a.jsx)(n.code,{children:"user"})," directly."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-toml",children:'[tool.ariadne-codegen]\n...\nplugins = ["ariadne_codegen.contrib.shorter_results.ShorterResultsPlugin"]\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"async def get_user(self, user_id: str) -> GetUserUser:\n    ...\n    return GetUser.parse_obj(data).user\n\n"})}),"\n",(0,a.jsx)(n.h2,{id:"discriminated-unions",children:"Discriminated unions"}),"\n",(0,a.jsxs)(n.p,{children:["To ensure that data is represented as a correct class we use pydantic's ",(0,a.jsx)(n.a,{href:"https://docs.pydantic.dev/dev-v2/usage/types/unions/#discriminated-unions-aka-tagged-unions",children:"discriminated unions"}),". We add ",(0,a.jsx)(n.code,{children:"__typename"})," to queries with unions and then use its value as ",(0,a.jsx)(n.code,{children:"discriminator"}),". Let's take an example schema and query:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-gql",children:"type Query {\n  animal: Animal!\n}\n\ninterface Animal {\n  name: String!\n}\n\ntype Dog implements Animal {\n  name: String!\n  dogField: String!\n}\n\ntype Cat implements Animal {\n  name: String!\n  catField: String!\n}\n\ntype Fish implements Animal {\n  name: String!\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-gql",children:"query GetAnimal {\n  animal {\n    name\n    ... on Dog {\n      dogField\n    }\n    ... on Cat {\n      catField\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"From this query and operation, we generate following types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:'class GetAnimal(BaseModel):\n    animal: Union[\n        "GetAnimalAnimalAnimal", "GetAnimalAnimalDog", "GetAnimalAnimalCat"\n    ] = Field(discriminator="typename__")\n\n\nclass GetAnimalAnimalAnimal(BaseModel):\n    typename__: Literal["Animal", "Fish"] = Field(alias="__typename")\n    name: str\n\n\nclass GetAnimalAnimalDog(BaseModel):\n    typename__: Literal["Dog"] = Field(alias="__typename")\n    name: str\n    dog_field: str = Field(alias="dogField")\n\n\nclass GetAnimalAnimalCat(BaseModel):\n    typename__: Literal["Cat"] = Field(alias="__typename")\n    name: str\n    cat_field: str = Field(alias="catField")\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We added ",(0,a.jsx)(n.code,{children:"typename__"})," to this query, and by its value pydantic determines which model to choose."]}),"\n",(0,a.jsx)(n.h2,{id:"leading-underscores",children:"Leading underscores"}),"\n",(0,a.jsxs)(n.p,{children:["Ariadne Codegen 0.7 will remove leading ",(0,a.jsx)(n.code,{children:"_"})," from field names. Fields with ",(0,a.jsx)(n.code,{children:"_"})," are ignored by pydantic and it is impossible to save the value of such fields."]}),"\n",(0,a.jsxs)(n.h2,{id:"removal-of-mixin-directive-from-operation-sent-to-a-server",children:["Removal of ",(0,a.jsx)(n.code,{children:"mixin"})," directive from operation sent to a server"]}),"\n",(0,a.jsxs)(n.p,{children:["We support a custom ",(0,a.jsx)(n.code,{children:"mixin"})," directive, which allows extending of generated types. In 0.7 we are removing it from the operation string included in generated client's methods. This directive is only used in the process of generation and caused servers to return errors because of an unknown directive."]}),"\n",(0,a.jsxs)(n.h2,{id:"process_schema-plugin-hook",children:[(0,a.jsx)(n.code,{children:"process_schema"})," plugin hook"]}),"\n",(0,a.jsxs)(n.p,{children:["Plugins can now define a ",(0,a.jsx)(n.code,{children:"process_schema"})," hook to change schema before Codegen uses it for generation. From now on we allow invalid schemas to be parsed from files or URLs, and then we call this plugin hook. After ",(0,a.jsx)(n.code,{children:"process_schema"})," is finished, the processed schema must pass ",(0,a.jsx)(n.code,{children:"graphql.assert_valid_schema"})," validation."]}),"\n",(0,a.jsx)(n.p,{children:"For example, it can be used to add Apollo Federation directives definitions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"class MyPlugin:\n    def process_schema(self, schema: GraphQLSchema) -> GraphQLSchema:\n        extends_directive_def = GraphQLDirective(...)\n        schema.directives += (extends_directive_def, )\n\n        return schema\n"})}),"\n",(0,a.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Added support for subscriptions as async generators."}),"\n",(0,a.jsx)(n.li,{children:"Changed how fragments are handled to generate separate module with fragments as mixins."}),"\n",(0,a.jsxs)(n.li,{children:["Fixed ",(0,a.jsx)(n.code,{children:"ResultTypesGenerator"})," to trigger ",(0,a.jsx)(n.code,{children:"generate_result_class"})," for each result model."]}),"\n",(0,a.jsx)(n.li,{children:"Changed processing of models fields to trim leading underscores."}),"\n",(0,a.jsxs)(n.li,{children:["Added ",(0,a.jsx)(n.code,{children:"ShorterResultsPlugin"})," to standard plugins."]}),"\n",(0,a.jsx)(n.li,{children:"Fixed handling of inline fragments inside other fragments."}),"\n",(0,a.jsx)(n.li,{children:"Changed generated unions to use pydantic's discriminated unions feature."}),"\n",(0,a.jsxs)(n.li,{children:["Replaced HTTPX's ",(0,a.jsx)(n.code,{children:"json="})," serializer for query payloads with pydantic's ",(0,a.jsx)(n.code,{children:"pydantic_encoder"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Removed ",(0,a.jsx)(n.code,{children:"mixin"})," directive from operation string sent to server."]}),"\n",(0,a.jsxs)(n.li,{children:["Fixed ",(0,a.jsx)(n.code,{children:"ShorterResultsPlugin"})," that generated faulty code for discriminated unions."]}),"\n",(0,a.jsx)(n.li,{children:"Changed generator to ignore unused fragments which should be unpacked in queries."}),"\n",(0,a.jsxs)(n.li,{children:["Changed type hints for parse and serialize methods of scalars to ",(0,a.jsx)(n.code,{children:"typing.Any"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Added ",(0,a.jsx)(n.code,{children:"process_schema"})," plugin hook."]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},84429:function(e,n,s){s.d(n,{R:()=>t,x:()=>l});var i=s(96540);let a={},r=i.createContext(a);function t(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(r.Provider,{value:n},e.children)}},12541:function(e){e.exports=JSON.parse('{"permalink":"/blog/2023/06/01/ariadne-codegen-0-7","source":"@site/blog/2023-06-01-ariadne-codegen-0-7.md","title":"Ariadne Codegen 0.7","description":"Ariadne Codegen 0.7 is now available!","date":"2023-06-01T00:00:00.000Z","tags":[],"readingTime":5.25,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Ariadne Codegen 0.7"},"unlisted":false,"prevItem":{"title":"Introducing Ariadne GraphQL Proxy","permalink":"/blog/2023/06/15/ariadne-graphql-proxy"},"nextItem":{"title":"Ariadne Codegen 0.6","permalink":"/blog/2023/04/18/ariadne-codegen-0-6"}}')}}]);