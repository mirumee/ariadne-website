"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["22553"],{79856:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>a,toc:()=>d,default:()=>c,metadata:()=>s,assets:()=>l,contentTitle:()=>o});var s=JSON.parse('{"id":"mutations","title":"Mutations","description":"All the previous examples in this documentation have dealt with the Query root type and reading data. What about creating, updating or deleting data?","source":"@site/server_versioned_docs/version-0.22/mutations.md","sourceDirName":".","slug":"/mutations","permalink":"/server/0.22/mutations","draft":false,"unlisted":false,"tags":[],"version":"0.22","frontMatter":{"id":"mutations","title":"Mutations"},"sidebar":"tutorialSidebar","previous":{"title":"Resolvers","permalink":"/server/0.22/resolvers"},"next":{"title":"Inputs","permalink":"/server/0.22/inputs"}}'),i=n(74848),r=n(84429);let a={id:"mutations",title:"Mutations"},o,l={},d=[{value:"Defining mutations",id:"defining-mutations",level:2},{value:"Writing resolvers",id:"writing-resolvers",level:2},{value:"Mutation results",id:"mutation-results",level:2}];function u(e){let t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["All the previous examples in this documentation have dealt with the ",(0,i.jsx)(t.code,{children:"Query"})," root type and reading data. What about creating, updating or deleting data?"]}),"\n",(0,i.jsxs)(t.p,{children:["Enter the ",(0,i.jsx)(t.code,{children:"Mutation"})," type, ",(0,i.jsx)(t.code,{children:"Query"}),"'s sibling that GraphQL servers use to implement functions that change application state."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["Because there is no restriction on what can be done inside resolvers, technically there's nothing stopping somebody from making ",(0,i.jsx)(t.code,{children:"Query"})," fields act as ",(0,i.jsx)(t.code,{children:"Mutation"}),"s, taking inputs and executing state-changing logic."]}),"\n",(0,i.jsx)(t.p,{children:"In practice, such queries break the contract with client libraries such as Apollo-Client that do client-side caching and state management, resulting in non-responsive controls or inaccurate information being displayed in the UI as the library displays cached data before redrawing it to display an actual response from the GraphQL."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"defining-mutations",children:"Defining mutations"}),"\n",(0,i.jsx)(t.p,{children:"Let's define the basic schema that implements a simple authentication mechanism allowing the client to see if they are authenticated, and to log in and log out:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'type_def = """\n    type Query {\n        isAuthenticated: Boolean!\n    }\n\n    type Mutation {\n        login(username: String!, password: String!): Boolean!\n        logout: Boolean!\n    }\n"""\n'})}),"\n",(0,i.jsx)(t.p,{children:"In this example we have the following elements:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Query"})," type with single field: a boolean for checking if we are authenticated or not. It may appear superficial for the sake of this example, ",(0,i.jsx)(t.em,{children:"but Ariadne requires"})," that your GraphQL API always defines a ",(0,i.jsx)(t.code,{children:"Query"})," type."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Mutation"})," type with two mutations:","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"login"})," mutation that requires username and password strings and returns a boolean indicating status."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"logout"})," that takes no arguments and just returns status."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"writing-resolvers",children:"Writing resolvers"}),"\n",(0,i.jsxs)(t.p,{children:["Mutation resolvers are no different than resolvers used by other types. They are functions that take ",(0,i.jsx)(t.code,{children:"parent"})," and ",(0,i.jsx)(t.code,{children:"info"})," arguments, as well as any mutation's arguments as keyword arguments. They then return data that should be sent to the client as a query result:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'def resolve_login(_, info, username, password):\n    request = info.context["request"]\n    user = auth.authenticate(username, password)\n    if user:\n        auth.login(request, user)\n        return True\n    return False\n\n\ndef resolve_logout(_, info):\n    request = info.context["request"]\n    if request.user.is_authenticated:\n        auth.logout(request)\n        return True\n    return False\n'})}),"\n",(0,i.jsxs)(t.p,{children:["You can map resolvers to mutations using a ",(0,i.jsx)(t.code,{children:"MutationType"})," object:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'from ariadne import MutationType\nfrom . import auth_mutations\n\nmutation = MutationType()\nmutation.set_field("login", auth_mutations.resolve_login)\nmutation.set_field("logout", auth_mutations.resolve_logout)\n'})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"MutationType()"})," is just a shortcut for ",(0,i.jsx)(t.code,{children:'ObjectType("Mutation")'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"MutationType"})," objects include a ",(0,i.jsx)(t.code,{children:"field()"})," decorator for mapping resolvers to mutations:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'mutation = MutationType()\n\n@mutation.field("logout")\ndef resolve_logout(_, info):\n    ...\n'})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Binding Mutation Resolvers"})}),"\n",(0,i.jsxs)(t.p,{children:["Recall that resolvers need to be bound to their respective resolvers via the ",(0,i.jsx)(t.code,{children:"make_executable_schema"})," call. If you're following along from the introduction that call will look similar to the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"make_executable_schema(type_defs, [query, mutations])\n"})}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"mutation-results",children:"Mutation results"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"login"})," and ",(0,i.jsx)(t.code,{children:"logout"})," mutations introduced earlier in this guide work, but give very limited feedback to the client: they return either ",(0,i.jsx)(t.code,{children:"False"})," or ",(0,i.jsx)(t.code,{children:"True"}),".  The application could use additional information like an error message that could be displayed in the interface if the mutation request fails, or a user state updated after a mutation completed."]}),"\n",(0,i.jsxs)(t.p,{children:["In GraphQL this is achieved by making mutations return special ",(0,i.jsx)(t.em,{children:"result"})," types containing additional information about the result, such as errors or current object state:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'type_def = """\n    type Mutation {\n        login(username: String!, password: String!): LoginResult\n    }\n\n    type LoginResult {\n        status: Boolean!\n        error: Error\n        user: User\n    }\n"""\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The above mutation will return a special type containing information about the mutation's status, as well as either an ",(0,i.jsx)(t.code,{children:"Error"})," message or a logged in ",(0,i.jsx)(t.code,{children:"User"}),". In Python this result can be represented as a simple ",(0,i.jsx)(t.code,{children:"dict"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'def resolve_login(_, info, username, password):\n    request = info.context["request"]\n    user = auth.authenticate(username, password)\n    if user:\n        auth.login(request, user)\n        return {"status": True, "user": user}\n    return {"status": False, "error": "Invalid username or password"}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Let's take one more look at the result's fields:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"status"})," makes it easier for the frontend logic to check if mutation succeeded or not."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"error"})," contains an error message returned by mutation or ",(0,i.jsx)(t.code,{children:"null"}),". Errors can be simple strings, or more complex types that contain additional information for use by the client."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"user"})," field is especially noteworthy. Modern GraphQL client libraries like ",(0,i.jsx)(t.a,{href:"https://www.apollographql.com/docs/react/",children:"Apollo Client"})," implement automatic caching and state management, using GraphQL types to track and automatically update stored object data whenever a new one is returned from the API."]}),"\n",(0,i.jsx)(t.p,{children:"Consider a mutation that changes a user's username and its result:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-graphql",children:"type Mutation {\n    updateUsername(id: ID!, username: String!): userMutationResult\n}\n\ntype UsernameMutationResult {\n    status: Boolean!\n    error: Error\n    user: User\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Our client code may first perform an ",(0,i.jsx)(t.em,{children:"optimistic update"})," before the API executes a mutation and returns a response to client. This optimistic update will cause an immediate update of the application interface, making it appear fast and responsive to the user. When the mutation eventually completes a moment later and returns an updated ",(0,i.jsx)(t.code,{children:"user"})," one of two things will happen:"]}),"\n",(0,i.jsx)(t.p,{children:"If the mutation succeeded, the user doesn't see another UI update because the new data returned by the mutation was the same as the one set by the optimistic update. If the mutation asked for additional user fields that are dependant on username but weren't set optimistically (like link or user name changes history), those will be updated too."}),"\n",(0,i.jsxs)(t.p,{children:["If the mutation failed, changes performed by an optimistic update are overwritten by valid user state that contains the pre-changed username. The client then uses the ",(0,i.jsx)(t.code,{children:"error"})," field to display an error message in the interface."]}),"\n",(0,i.jsx)(t.p,{children:"For the above reasons it is considered a good design for mutations to return an updated object whenever possible."}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["There is no requirement for every mutation to have its own ",(0,i.jsx)(t.code,{children:"Result"})," type. ",(0,i.jsx)(t.code,{children:"login"})," and ",(0,i.jsx)(t.code,{children:"logout"})," mutations can both define ",(0,i.jsx)(t.code,{children:"LoginResult"})," as their return type. It is up to the developer to decide how generic or specific mutation results should be."]}),"\n"]})]})}function c(e={}){let{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},84429:function(e,t,n){n.d(t,{R:()=>a,x:()=>o});var s=n(96540);let i={},r=s.createContext(i);function a(e){let t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);