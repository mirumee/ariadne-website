"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["22657"],{12195:function(e,i,t){t.r(i),t.d(i,{frontMatter:()=>o,toc:()=>d,default:()=>u,metadata:()=>n,assets:()=>a,contentTitle:()=>l});var n=JSON.parse('{"id":"query-validators","title":"Query validators","description":"GraphQL uses query validators to check if Query AST is valid and can be executed. Every GraphQL server implements standard query validators. For example, there is an validator that tests if queried field exists on queried type, that makes query fail with \\"Cannot query field on type\\" error if it doesn\'t.","source":"@site/server_versioned_docs/version-0.13.0/query-validators.md","sourceDirName":".","slug":"/query-validators","permalink":"/server/0.13.0/query-validators","draft":false,"unlisted":false,"tags":[],"version":"0.13.0","frontMatter":{"id":"query-validators","title":"Query validators"},"sidebar":"tutorialSidebar","previous":{"title":"Middleware","permalink":"/server/0.13.0/middleware"},"next":{"title":"ariadne","permalink":"/server/0.13.0/api-reference"}}'),s=t(74848),r=t(84429);let o={id:"query-validators",title:"Query validators"},l,a={},d=[{value:"Query cost validator",id:"query-cost-validator",level:2},{value:"Setting fields costs in schema",id:"setting-fields-costs-in-schema",level:3},{value:"Setting fields costs in Python",id:"setting-fields-costs-in-python",level:3},{value:"Setting default field cost and complexity",id:"setting-default-field-cost-and-complexity",level:3},{value:"Configuring <code>cost_validator</code> dynamically",id:"configuring-cost_validator-dynamically",level:3},{value:"Complexity of lists of items",id:"complexity-of-lists-of-items",level:3},{value:"Implementing custom validator",id:"implementing-custom-validator",level:2}];function c(e){let i={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.p,{children:'GraphQL uses query validators to check if Query AST is valid and can be executed. Every GraphQL server implements standard query validators. For example, there is an validator that tests if queried field exists on queried type, that makes query fail with "Cannot query field on type" error if it doesn\'t.'}),"\n",(0,s.jsx)(i.p,{children:"Ariadne supports extending this server behaviour by including custom query validators."}),"\n",(0,s.jsx)(i.h2,{id:"query-cost-validator",children:"Query cost validator"}),"\n",(0,s.jsx)(i.p,{children:"Query cost validation allows server owners to limit maximal allowed cost (or complexity) of GraphQL query. This forces malicious clients to run multiple HTTP requests which in turn allows server owners to limit or filter off their traffic through HTTP server settings."}),"\n",(0,s.jsxs)(i.p,{children:["First, query cost validator needs to be enabled on GraphQL server using ",(0,s.jsx)(i.code,{children:"validation_rules"})," option:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"from ariadne.asgi import GraphQL\nfrom ariadne.validation import cost_validator\n\nschema = make_executable_schema() # make_executable_schema call with type definitions, resolvers, etc. ect.\n\ngraphql = Graphql(\n    schema,\n    validation_rules=[cost_validator(maximum_cost=5)]\n)\n"})}),"\n",(0,s.jsx)(i.p,{children:"Next step is assigning costs values to schema fields. This can be done in Python or in the schema."}),"\n",(0,s.jsx)(i.h3,{id:"setting-fields-costs-in-schema",children:"Setting fields costs in schema"}),"\n",(0,s.jsxs)(i.p,{children:["To set fields costs in schema, first add ",(0,s.jsx)(i.code,{children:"cost"})," directive definition to it:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-graphql",children:"directive @cost(complexity: Int, multipliers: [String!], useMultipliers: Boolean) on FIELD | FIELD_DEFINITION\n"})}),"\n",(0,s.jsx)(i.p,{children:"To make your schema future proof, directive's definition is available as import from Ariadne:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from ariadne.validation import cost_directive\n\nschema = make_executable_schema([type_defs, cost_directive], ...)\n"})}),"\n",(0,s.jsxs)(i.p,{children:["Now you can use this directive to assign costs to selected fields. For example, you can set cost of accessing ",(0,s.jsx)(i.code,{children:"poster"})," field on ",(0,s.jsx)(i.code,{children:"Post"})," type as ",(0,s.jsx)(i.code,{children:"3"})," like this:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-graphql",children:"type Post {\n    id: ID\n    name: String\n    poster: User @cost(complexity: 3)\n}\n"})}),"\n",(0,s.jsxs)(i.p,{children:["If you want to, you can make cost depend on the value of one or more of ",(0,s.jsx)(i.code,{children:"Int"})," arguments that field accepts:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-graphql",children:'type Query {\n    news(promoted: Int, regular: Int): Post @cost(complexity: 1, multipliers: ["promoted", "regular"])\n}\n'})}),"\n",(0,s.jsxs)(i.p,{children:["In the above example, final complexity will be multiplied by both ",(0,s.jsx)(i.code,{children:"promoted"})," and ",(0,s.jsx)(i.code,{children:"regular"})," values."]}),"\n",(0,s.jsxs)(i.p,{children:["You can also use ",(0,s.jsx)(i.code,{children:"useMultipliers"})," to remove query cost mulitplication for specified field without removing ",(0,s.jsx)(i.code,{children:"@cost"})," from it:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-graphql",children:'type Query {\n    news(promoted: Int): Post @cost(complexity: 1, multipliers: ["promoted"], useMultipliers: false)\n}\n'})}),"\n",(0,s.jsx)(i.h3,{id:"setting-fields-costs-in-python",children:"Setting fields costs in Python"}),"\n",(0,s.jsxs)(i.p,{children:["Fields costs can be set using Python dict passed as an option to ",(0,s.jsx)(i.code,{children:"cost_validator"}),":"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'cost_map = {\n    "Query": {\n        "news": {"complexity": 1, "multipliers": ["promoted", "regular"]},\n    },\n    "Post": {\n        "poster": {"complexity": 3},\n    },\n}\n\ngraphql = Graphql(\n    type_defs,\n    validation_rules=[cost_validator(maximum_cost=5, cost_map=cost_map)]\n)\n'})}),"\n",(0,s.jsx)(i.h3,{id:"setting-default-field-cost-and-complexity",children:"Setting default field cost and complexity"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"cost_validator"})," supports two additional options to make configuring costs less verbose:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"default_complexity: int"})," - Default value for field ",(0,s.jsx)(i.code,{children:"complexity"})," if its omitted from ",(0,s.jsx)(i.code,{children:"@cost"})," or ",(0,s.jsx)(i.code,{children:"price_map"}),". Defaults to ",(0,s.jsx)(i.code,{children:"1"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"default_cost: int"})," - Default base value for field cost. Defaults to ",(0,s.jsx)(i.code,{children:"0"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(i.h3,{id:"configuring-cost_validator-dynamically",children:["Configuring ",(0,s.jsx)(i.code,{children:"cost_validator"})," dynamically"]}),"\n",(0,s.jsxs)(i.p,{children:["Because ",(0,s.jsx)(i.code,{children:"validation_rules"})," option can be a ",(0,s.jsx)(i.code,{children:"callable"})," (eg. function), it can be used to dynamically configure query costs validation based on GraphQL context or even parsed query itself:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'def get_validation_rules(context_value, document, data):\n    user = context_value.get("user")\n    if user:\n        if user.is_admin:\n            return None\n        if user.is_high_ltv:\n            return [cost_validator(maximum_cost=15)]\n    \n    return [cost_validator(maximum_cost=5)]\n\n\ngraphql = Graphql(\n    schema,\n    validation_rules=get_validation_rules\n)\n'})}),"\n",(0,s.jsx)(i.h3,{id:"complexity-of-lists-of-items",children:"Complexity of lists of items"}),"\n",(0,s.jsx)(i.p,{children:"Query cost validation runs before query execution. This makes it impossible for field cost to depend on real number of returned children."}),"\n",(0,s.jsx)(i.p,{children:"To deal with that you should use either multipliers, dynamic query cost configuration or make field's cost high enough in advance."}),"\n",(0,s.jsx)(i.h2,{id:"implementing-custom-validator",children:"Implementing custom validator"}),"\n",(0,s.jsxs)(i.p,{children:["All custom query validators should extend the ",(0,s.jsx)(i.a,{href:"https://github.com/graphql-python/graphql-core/blob/v3.0.5/src/graphql/validation/rules/__init__.py#L37",children:(0,s.jsx)(i.code,{children:"ValidationRule"})})," base class importable from the ",(0,s.jsx)(i.code,{children:"graphql.validation.rules"})," module."]}),"\n",(0,s.jsxs)(i.p,{children:["Query validators are visitor classes. They are instantiated at the time of query validation with one required argument (",(0,s.jsx)(i.code,{children:"context: ASTValidationContext"}),")."]}),"\n",(0,s.jsxs)(i.p,{children:["In order to perform validation, your validator class should define one or more of ",(0,s.jsx)(i.code,{children:"enter_*"})," and ",(0,s.jsx)(i.code,{children:"leave_*"})," methods. For possible enter/leave items as well as details on function documentation, please see contents of the ",(0,s.jsx)(i.a,{href:"https://github.com/graphql-python/graphql-core/blob/v3.0.5/src/graphql/language/visitor.py",children:(0,s.jsx)(i.code,{children:"visitor"})})," module."]}),"\n",(0,s.jsxs)(i.p,{children:["To make validation fail, you should call validator's ",(0,s.jsx)(i.code,{children:"report_error"})," method with the instance of ",(0,s.jsx)(i.code,{children:"GraphQLError"})," describing failure reason."]}),"\n",(0,s.jsx)(i.p,{children:"Here is an example query validator that visits field definitions in GraphQL query and fails query validation if any of those fields are introspection fields:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from graphql import GraphQLError\nfrom graphql.language import FieldNode\nfrom graphql.validation import ValidationRule\n\n\ndef is_introspection_field(field_name: str):\n    return key.lower() in [\n        "__schema",\n        "__directive",\n        "__directivelocation",\n        "__type",\n        "__field",\n        "__inputvalue",\n        "__enumvalue",\n        "__typekind",\n    ]\n\n\nclass IntrospectionDisabledRule(ValidationRule):\n    def enter_field(self, node: FieldNode, *_args):\n        field_name = node.name.value\n        if not is_introspection_key(field_name):\n            return\n\n        self.report_error(\n            GraphQLError(\n                f"Cannot query \'{field_name}\': introspection is disabled.", node,\n            )\n        )\n\n'})})]})}function u(e={}){let{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},84429:function(e,i,t){t.d(i,{R:()=>o,x:()=>l});var n=t(96540);let s={},r=n.createContext(s);function o(e){let i=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);