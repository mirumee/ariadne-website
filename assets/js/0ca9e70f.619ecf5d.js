"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["58805"],{36767:function(e,s,n){n.r(s),n.d(s,{frontMatter:()=>i,toc:()=>l,default:()=>u,metadata:()=>r,assets:()=>d,contentTitle:()=>o});var r=JSON.parse('{"id":"dataloaders","title":"Dataloaders","description":"Dataloaders are a GraphQL pattern for solving the N+1 problem, where retrieval of N number of items results in N + 1 number of data retrieval operations.","source":"@site/server_versioned_docs/version-0.21/dataloaders.md","sourceDirName":".","slug":"/dataloaders","permalink":"/server/0.21/dataloaders","draft":false,"unlisted":false,"tags":[],"version":"0.21","frontMatter":{"id":"dataloaders","title":"Dataloaders"},"sidebar":"tutorialSidebar","previous":{"title":"Subscriptions","permalink":"/server/0.21/subscriptions"},"next":{"title":"File uploads","permalink":"/server/0.21/file-uploads"}}'),a=n(74848),t=n(84429);let i={id:"dataloaders",title:"Dataloaders"},o,d={},l=[{value:"The &quot;N+1&quot; problem",id:"the-n1-problem",level:2},{value:"Half-measures",id:"half-measures",level:2},{value:"Dataloader",id:"dataloader",level:2},{value:"Async dataloader",id:"async-dataloader",level:2},{value:"Loader function",id:"loader-function",level:3},{value:"Initializing loader in context",id:"initializing-loader-in-context",level:3},{value:"Using loader in resolvers",id:"using-loader-in-resolvers",level:3},{value:"Cache",id:"cache",level:3},{value:"Sync dataloader",id:"sync-dataloader",level:2},{value:"Loader function",id:"loader-function-1",level:3},{value:"Initializing loader in context",id:"initializing-loader-in-context-1",level:3},{value:"Using loader in resolvers",id:"using-loader-in-resolvers-1",level:3},{value:"Cache",id:"cache-1",level:3}];function c(e){let s={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(s.p,{children:["Dataloaders are a GraphQL pattern for solving the N+1 problem, where retrieval of ",(0,a.jsx)(s.strong,{children:"N number of items"})," results in ",(0,a.jsx)(s.strong,{children:"N + 1 number of data retrieval operations"}),"."]}),"\n",(0,a.jsx)(s.h2,{id:"the-n1-problem",children:'The "N+1" problem'}),"\n",(0,a.jsx)(s.p,{children:"Let's take the GraphQL schema modeling a simple relation where messages have users who posted them:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-graphql",children:"type Query {\n    messages: [Message!]!\n}\n\ntype Message {\n    id: ID!\n    message: String!\n    poster: User\n}\n\ntype User {\n    id: ID!\n    name: String!\n}\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Resolver for ",(0,a.jsx)(s.code,{children:"messages"})," field selects messages from database ordered by their id in reverse order:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'def resolve_query_messages(*_):\n    return db_fetch_all(\n        "SELECT id, poster_id, message FROM messages ORDER BY id DESC"\n    )\n'})}),"\n",(0,a.jsxs)(s.p,{children:["Resolver for ",(0,a.jsx)(s.code,{children:"poster"})," field checks if message has id of a user who posted it, and if it does, retrieves this user from the database:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'def resolve_message_poster(message, *_):\n    if not message["poster_id"]:\n        return None  # Skip database query when message has no poster\n\n    return db_fetch_one(\n        "SELECT id, name FROM users WHERE id = %s", message["poster_id"]\n    )\n'})}),"\n",(0,a.jsxs)(s.p,{children:["Assuming that there are ",(0,a.jsx)(s.strong,{children:"20 rows"})," in ",(0,a.jsx)(s.code,{children:"messages"})," table in database, this GraphQL query will ",(0,a.jsx)(s.strong,{children:"cause 21 database queries"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-graphql",children:"query SelectMessages {\n    messages {\n        id\n        message\n        poster {\n            id\n            name\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(s.p,{children:"There's 1 database query for messages which returns 20 rows, each row causing one extra database query:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"SELECT id, poster_id, message FROM messages ORDER BY id DESC;\nSELECT id, name FROM users WHERE id = 39;\nSELECT id, name FROM users WHERE id = 31;\nSELECT id, name FROM users WHERE id = 39;\nSELECT id, name FROM users WHERE id = 96;\nSELECT id, name FROM users WHERE id = 19;\nSELECT id, name FROM users WHERE id = 63;\nSELECT id, name FROM users WHERE id = 32;\nSELECT id, name FROM users WHERE id = 34;\nSELECT id, name FROM users WHERE id = 48;\nSELECT id, name FROM users WHERE id = 12;\nSELECT id, name FROM users WHERE id = 12;\nSELECT id, name FROM users WHERE id = 12;\nSELECT id, name FROM users WHERE id = 41;\nSELECT id, name FROM users WHERE id = 98;\nSELECT id, name FROM users WHERE id = 19;\nSELECT id, name FROM users WHERE id = 42;\nSELECT id, name FROM users WHERE id = 46;\nSELECT id, name FROM users WHERE id = 31;\nSELECT id, name FROM users WHERE id = 48;\nSELECT id, name FROM users WHERE id = 92;\n"})}),"\n",(0,a.jsxs)(s.p,{children:["20 rows is our ",(0,a.jsx)(s.code,{children:"N"}),", and extra query is ",(0,a.jsx)(s.code,{children:"+1"}),'. This is the famous "N+1" problem in action.']}),"\n",(0,a.jsx)(s.h2,{id:"half-measures",children:"Half-measures"}),"\n",(0,a.jsx)(s.p,{children:"There are some solutions to this problem that can be implemented quickly, but have their own drawbacks."}),"\n",(0,a.jsxs)(s.p,{children:["For example, we can update ",(0,a.jsx)(s.code,{children:"messages"})," resolver to use database ",(0,a.jsx)(s.code,{children:"JOIN"})," operation, thus retrieving messages together with their posters:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'def resolve_query_messages(*_):\n    return db_fetch_all(\n        """\n        SELECT m.id, m.poster_id, m.message, u.id AS u_id, u.name AS u_name\n        FROM messages AS m\n        LEFT JOIN users AS u ON m.poster_id = u.id;\n        ORDER BY m.id DESC\n        """\n    )\n'})}),"\n",(0,a.jsxs)(s.p,{children:["Now we can update ",(0,a.jsx)(s.code,{children:"poster"})," resolver to pull user's data from result:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'def resolve_message_poster(message, *_):\n    if not message["u_id"]:\n        return None  # Skip when message has no poster\n\n    return {\n        "id": message["u_id"],\n        "name": message["u_name"],\n    }\n'})}),"\n",(0,a.jsxs)(s.p,{children:["This change is enough to fix the issue. If we are using an ORM, it may not even require ",(0,a.jsx)(s.code,{children:"resolve_message_poster"})," resolver to exist at all because ",(0,a.jsx)(s.code,{children:"message"})," object will have ",(0,a.jsx)(s.code,{children:"poster"})," attribute populated by the joined value."]}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"But"})," if GraphQL query doesn't include the ",(0,a.jsx)(s.code,{children:"poster"})," field, we now potentially spend a lot of extra work and memory retrieving data we won't use. This is the overfetching problem that GraphQL is supposed to solve, even if this time its limited to server only."]}),"\n",(0,a.jsx)(s.p,{children:"What if instead of database we are using remote API? We will still need to run two API calls:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'def resolve_query_messages(*_):\n    messages = client.get("http://api.example.com/messages/")\n\n    posters = {\n        message["poster_id"]: None\n        for message in messages if message["poster_id"]\n    }\n\n    if posters:\n        api_qs = "&".join(f"id={uid}" for uid in posters)\n        api_url = f"http://api.example.com/users/?{api_qs}"\n\n        for poster in client.get(api_url):\n            posters[poster["id"]] = poster\n\n        for message in messages:\n            message["poster"] = posters.get(message["poster_id"])\n\n    return messages\n'})}),"\n",(0,a.jsxs)(s.p,{children:["There's quite a lot of extra logic. What if there are more lists of items that have relation to ",(0,a.jsx)(s.code,{children:"user"}),"? Most likely we will now have an util for our resolvers to fetch their users:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'def get_users_from_api(users_ids: list[int]) -> dict[int, dict]:\n    if not users_ids:\n        return {}\n\n    api_values = "&".join(f"id={uid}" for uid in users_ids)\n    api_url = f"http://api.example.com/users/?{api_values}"\n\n    return {user["id"]: user for user in client.get(api_url)}\n'})}),"\n",(0,a.jsxs)(s.p,{children:["We are now a ",(0,a.jsx)(s.strong,{children:"half"}),"-way to implementing a dataloader. \u{1F44F}"]}),"\n",(0,a.jsx)(s.h2,{id:"dataloader",children:"Dataloader"}),"\n",(0,a.jsx)(s.p,{children:"Dataloader is a proxy to a data source. What this data source is doesn't matter. For performance reasons its important that this source supports bulk retrieval of items, but thats not required."}),"\n",(0,a.jsxs)(s.p,{children:["Dataloader ",(0,a.jsx)(s.strong,{children:"knows"})," how to retrieve required objects in most optimal way."]}),"\n",(0,a.jsxs)(s.p,{children:["Dataloader ",(0,a.jsx)(s.strong,{children:"batches"})," multiple retrieval operations into one."]}),"\n",(0,a.jsxs)(s.p,{children:["Dataloader ",(0,a.jsx)(s.strong,{children:"may"})," cache retrieved items to make repeated retrievals faster."]}),"\n",(0,a.jsxs)(s.p,{children:["In short, dataloader is ",(0,a.jsx)(s.strong,{children:"magic"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'def load_user(user_id: int) -> Optional[dict]:\n    # \u{1F31F} magic \u{1F31F}\n\n\ndef resolve_message_poster(message, *_):\n    if not message["poster_id"]:\n        return None  # Skip when message has no poster\n\n    return load_user(message["poster_id"])\n'})}),"\n",(0,a.jsx)(s.h2,{id:"async-dataloader",children:"Async dataloader"}),"\n",(0,a.jsxs)(s.p,{children:["If you are using ",(0,a.jsx)(s.code,{children:"async"})," approach (eg. ",(0,a.jsx)(s.code,{children:"ariadne.graphql"})," or ",(0,a.jsx)(s.code,{children:"ariadne.asgi.GraphQL"}),"), use ",(0,a.jsx)(s.a,{href:"https://github.com/syrusakbary/aiodataloader",children:(0,a.jsx)(s.code,{children:"aiodataloader"})}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:"$ pip install aiodataloader\n"})}),"\n",(0,a.jsx)(s.h3,{id:"loader-function",children:"Loader function"}),"\n",(0,a.jsxs)(s.p,{children:["After installing ",(0,a.jsx)(s.code,{children:"aiodataloader"}),", we will need to first define function it will use to load data."]}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"aiodataloader"})," requires those functions to take single argument (list of IDs of objects to retrieve), and return a list with retrieved objects, in the order of ids it was called with, with items that couldn't be found represented as ",(0,a.jsx)(s.code,{children:"None"}),"."]}),"\n",(0,a.jsxs)(s.p,{children:["In this example we will continue using the ",(0,a.jsx)(s.code,{children:"get_users_from_api"})," function, but we need to make some changes to it first."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'from httpx import AsyncClient\n\nasync def get_users_from_api(users_ids: list[int]) -> list[dict]:\n    # Build API URL\n    api_values = "&".join(f"id={uid}" for uid in users_ids)\n    api_url = f"http://api.example.com/users/?{api_values}"\n\n    # Fetch users from API\n    async with AsyncClient() as client:\n        ids_map = {user["id"]: user for user in await client.get(api_url)}\n\n    # Return user as list using same order as users_ids passed to function\n    # Replace result with none when user with given id was not returned\n    return [ids_map.get(uid) for uid in users_ids]\n'})}),"\n",(0,a.jsx)(s.h3,{id:"initializing-loader-in-context",children:"Initializing loader in context"}),"\n",(0,a.jsxs)(s.p,{children:["We now need to store instance of ",(0,a.jsx)(s.code,{children:"aiodataloader.DataLoader"})," with our function in a place that's bound to HTTP request but also accessible by our GraphQL resolvers. GraphQL ",(0,a.jsx)(s.code,{children:"context"})," was created exactly for this case:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'from aiodataloader import DataLoader\nfrom ariadne.asgi import GraphQL\nfrom httpx import AsyncClient\nfrom starlette.requests import Request\n\nfrom .schema import schema\n\n\nasync def get_users_from_api(users_ids: list[int]) -> list[dict]:\n    # Build API URL\n    api_values = "&".join(f"id={uid}" for uid in users_ids)\n    api_url = f"http://api.example.com/users/?{api_values}"\n\n    # Fetch users from API\n    async with AsyncClient() as client:\n        ids_map = {user["id"]: user for user in await client.get(api_url)}\n\n    # Return user as list using same order as users_ids passed to function\n    # Replace result with none when user with given id was not returned\n    return [ids_map.get(uid) for uid in users_ids]\n\n\ndef get_context_value(request: Request):\n    # Context value function will be called for every request to GraphQL server\n    # Its retrievable as `context` attribute of resolver\'s second argument\n    return {\n        "request": request,\n        "user_loader": DataLoader(get_users_from_api)\n    }\n\nasgi_app = GraphQL(schema, context_value=get_context_value)\n'})}),"\n",(0,a.jsx)(s.h3,{id:"using-loader-in-resolvers",children:"Using loader in resolvers"}),"\n",(0,a.jsxs)(s.p,{children:["We can now update our ",(0,a.jsx)(s.code,{children:"poster"})," resolver to use the loader:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'def resolve_message_poster(message, info):\n    if not message["u_id"]:\n        return None  # Skip when message has no poster\n\n    return info.context["user_loader"].load(message["u_id"])\n'})}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"DataLoader.load()"})," takes id of an object to load, and returns awaitable for this object or ",(0,a.jsx)(s.code,{children:"None"})," (when it could not be loaded). GraphQL resolvers can be ",(0,a.jsx)(s.code,{children:"async"}),", but can also just return awaitable values. Below resolver behaves the same as previous one during GraphQL query execution:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'async def resolve_message_poster(message, info):\n    if not message["u_id"]:\n        return None  # Skip when message has no poster\n\n    return await info.context["user_loader"].load(message["u_id"])\n'})}),"\n",(0,a.jsxs)(s.p,{children:["It doesn't matter which approach you use, but if you want to do something with loaded value before returning it from resolver, you will need ",(0,a.jsx)(s.code,{children:"async"})," resolver that awaits it before returning it:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'async def resolve_message_poster(message, info):\n    if not message["u_id"]:\n        return None  # Skip when message has no poster\n\n    user = await info.context["user_loader"].load(message["u_id"])\n\n    # Test if loaded user was banned and don\'t return them if so\n    if not user or user.is_banned:\n        return None\n\n    return user\n'})}),"\n",(0,a.jsx)(s.h3,{id:"cache",children:"Cache"}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"DataLoader"})," caches previously loaded objects on it's instance, so repeated calls to ",(0,a.jsx)(s.code,{children:"load"})," previously loaded objects don't trigger new loads."]}),"\n",(0,a.jsxs)(s.p,{children:["This cache can become stale in situations when mutation resolver changes application state. If this happens you can manually remove the object from cache using ",(0,a.jsx)(s.code,{children:"clear(key)"})," method, or clear entire cache with ",(0,a.jsx)(s.code,{children:"clear_all"})," method:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'async def resolve_move_category_contents(_, info, **kwargs):\n    # ... logic doing something with category\n\n    # Remove category from categories dataloder\n    info.context["categories_loader"].clear(category.id)\n\n    # Clear threads and posts dataloaders cache because their category_id\n    # attributes are no longer valid and can cause problem in other resolvers\n    info.context["thread_loader"].clear_all()\n    info.context["post_loader"].clear_all()\n\n    return {"success": True}\n'})}),"\n",(0,a.jsxs)(s.p,{children:["You can also put object in the cache without loading it using ",(0,a.jsx)(s.code,{children:"prime"})," method:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'async def resolve_register_user_account(_, info, **kwargs):\n    # ... logic validating and registering `user` account\n\n    # Store user in dataloader in case it will be used by other resolvers\n    # during this GraphQL query\n    info.context["user_loader"].prime(user.id, user)\n\n    return {"user": user}\n'})}),"\n",(0,a.jsxs)(s.p,{children:["Initialize the ",(0,a.jsx)(s.code,{children:"DataLoader"})," with ",(0,a.jsx)(s.code,{children:"cache=False"})," to disable caching:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'def get_context_value(request: Request):\n    # Context value function will be called for every request to GraphQL server\n    # Its retrievable as `context` attribute of resolver\'s second argument\n    return {\n        "request": request,\n        "user_loader": DataLoader(get_users_from_api, cache=False)\n    }\n'})}),"\n",(0,a.jsx)(s.h2,{id:"sync-dataloader",children:"Sync dataloader"}),"\n",(0,a.jsxs)(s.p,{children:["If you are using sync approach, use ",(0,a.jsx)(s.a,{href:"https://github.com/jkimbo/graphql-sync-dataloaders",children:(0,a.jsx)(s.code,{children:"graphql-sync-dataloaders"})})," (Python 3.8 and later only):"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:"$ pip install graphql-sync-dataloaders\n"})}),"\n",(0,a.jsx)(s.h3,{id:"loader-function-1",children:"Loader function"}),"\n",(0,a.jsxs)(s.p,{children:["After installing ",(0,a.jsx)(s.code,{children:"graphql-sync-dataloaders"}),", we will need to first define function it will use to load data."]}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"graphql-sync-dataloaders"})," requires those functions to take single argument (list of IDs of objects to retrieve), and return a list with retrieved objects, in the order of ids it was called with, with items that couldn't be found represented as ",(0,a.jsx)(s.code,{children:"None"}),"."]}),"\n",(0,a.jsxs)(s.p,{children:["In this example we will continue using the ",(0,a.jsx)(s.code,{children:"get_users_from_api"})," function, but we need to make some changes to it first."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'import httpx\n\ndef get_users_from_api(users_ids: list[int]) -> list[dict]:\n    # Build API URL\n    api_values = "&".join(f"id={uid}" for uid in users_ids)\n    api_url = f"http://api.example.com/users/?{api_values}"\n\n    # Fetch users from API\n    ids_map = {user["id"]: user for user in httpx.get(api_url)}\n\n    # Return user as list using same order as users_ids passed to function\n    # Replace result with none when user with given id was not returned\n    return [ids_map.get(uid) for uid in users_ids]\n'})}),"\n",(0,a.jsx)(s.h3,{id:"initializing-loader-in-context-1",children:"Initializing loader in context"}),"\n",(0,a.jsxs)(s.p,{children:["We now need to store instance of ",(0,a.jsx)(s.code,{children:"graphql_sync_dataloaders.SyncDataLoader"})," with our function in a place that's bound to HTTP request but also accessible by our GraphQL resolvers. We will use GraphQL ",(0,a.jsx)(s.code,{children:"context"})," for this case, but we also need to set custom ",(0,a.jsx)(s.code,{children:"DeferredExecutionContext"})," GraphQL execution context class which knows about our dataloader."]}),"\n",(0,a.jsx)(s.p,{children:"Here's example Flask application:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'import requests\nfrom graphql_sync_dataloaders import DeferredExecutionContext, SyncDataLoader\nfrom ariadne import graphql_sync\nfrom flask import Flask, jsonify, request\n\nfrom .schema import schema\n\n\ndef get_users_from_api(users_ids: list[int]) -> list[dict]:\n    # Build API URL\n    api_values = "&".join(f"id={uid}" for uid in users_ids)\n    api_url = f"http://api.example.com/users/?{api_values}"\n\n    # Fetch users from API\n    ids_map = {user["id"]: user for user in httpx.get(api_url)}\n\n    # Return user as list using same order as users_ids passed to function\n    # Replace result with none when user with given id was not returned\n    return [ids_map.get(uid) for uid in users_ids]\n\n\napp = Flask(__name__)\n\n\n@app.route("/graphql", methods=["POST"])\ndef graphql_server():\n    data = request.get_json()\n\n    success, result = graphql_sync(\n        schema,\n        data,\n        # Context value with dataloader available as `user_loader`\n        context_value={\n            "request": request,\n            "user_loader": SyncDataLoader(get_users_from_api),\n        },\n        # Use DeferredExecutionContext as custom execution context\n        execution_context_class=DeferredExecutionContext,\n    )\n\n    status_code = 200 if success else 400\n    return jsonify(result), status_code\n\n\nif __name__ == "__main__":\n    app.run(debug=True)\n'})}),"\n",(0,a.jsx)(s.h3,{id:"using-loader-in-resolvers-1",children:"Using loader in resolvers"}),"\n",(0,a.jsxs)(s.p,{children:["We can now update our ",(0,a.jsx)(s.code,{children:"poster"})," resolver to use the loader:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'def resolve_message_poster(message, info):\n    if not message["u_id"]:\n        return None  # Skip when message has no poster\n\n    return info.context["user_loader"].load(message["u_id"])\n'})}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"SyncDataLoader.load()"})," takes id of an object to load, and returns ",(0,a.jsx)(s.code,{children:"SyncFuture"})," for this object or ",(0,a.jsx)(s.code,{children:"None"})," (when it could not be loaded). ",(0,a.jsx)(s.code,{children:"DeferredExecutionContext"})," then knows how to gather ",(0,a.jsx)(s.code,{children:"SyncFuture"})," returned by multiple resolver calls, then batch load and replace them with their results."]}),"\n",(0,a.jsxs)(s.p,{children:["If you want to do something with loaded object before returning it, you need to do it in a callback passed to it with ",(0,a.jsx)(s.code,{children:"then"})," method:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'def resolve_message_poster(message, info):\n    if not message["u_id"]:\n        return None  # Skip when message has no poster\n\n    def return_user_if_not_banned(user):\n        if not user or user.is_banned:\n            return None\n\n        return user\n\n    return info.context["user_loader"].load(\n        message["u_id"]\n    ).then(\n        return_user_if_not_banned\n    )\n'})}),"\n",(0,a.jsx)(s.h3,{id:"cache-1",children:"Cache"}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"SyncDataLoader"})," caches previously loaded objects on it's instance, so repeated calls to ",(0,a.jsx)(s.code,{children:"load"})," previously loaded objects don't trigger new loads."]}),"\n",(0,a.jsxs)(s.p,{children:["This cache can become stale in situations when mutation resolver changes application state. If this happens you can manually remove the object from cache using ",(0,a.jsx)(s.code,{children:"clear(key)"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'async def resolve_move_category_contents(_, info, **kwargs):\n    # ... logic doing something with category\n\n    # Remove category from categories dataloder\n    info.context["categories_loader"].clear(category.id)\n\n    return {"success": True}\n'})}),"\n",(0,a.jsxs)(s.p,{children:["Unlike ",(0,a.jsx)(s.code,{children:"DataLoader"}),", ",(0,a.jsx)(s.code,{children:"SyncDataLoader"})," doesn't provide an API for clearing entire cache or priming objects."]})]})}function u(e={}){let{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},84429:function(e,s,n){n.d(s,{R:()=>i,x:()=>o});var r=n(96540);let a={},t=r.createContext(a);function i(e){let s=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);