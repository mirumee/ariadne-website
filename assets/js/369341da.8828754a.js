"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["83013"],{56942:function(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>o});var d=i(57445),s=i(74848),a=i(84429);let r={title:"Ariadne Codegen 0.8"},t,l={authorsImageUrls:[]},o=[{value:"File uploads",id:"file-uploads",level:2},{value:"Pydantic v2",id:"pydantic-v2",level:2},{value:"Improved custom scalars",id:"improved-custom-scalars",level:2},{value:"Mixin directive",id:"mixin-directive",level:2},{value:"Field names",id:"field-names",level:2},{value:"Unified annotations",id:"unified-annotations",level:2},{value:"Changelog",id:"changelog",level:2}];function c(e){let n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Ariadne Codegen 0.8 has been released!"}),"\n",(0,s.jsx)(n.p,{children:"This release brings support for file uploads, pydantic v2 compliance, improved custom scalars handling, and few other features and fixes."}),"\n",(0,s.jsx)(n.h2,{id:"file-uploads",children:"File uploads"}),"\n",(0,s.jsxs)(n.p,{children:["From now on, the default base client (sync or async) checks if any part of ",(0,s.jsx)(n.code,{children:"variables"})," is an instance of ",(0,s.jsx)(n.code,{children:"Upload"}),". If such an instance is found, the client sends a multipart request according to ",(0,s.jsx)(n.a,{href:"https://github.com/jaydenseric/graphql-multipart-request-spec",children:"GraphQL multipart request specification"}),". ",(0,s.jsx)(n.code,{children:"Upload"})," is a class that stores necessary data about the file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class Upload:\n    def __init__(self, filename: str, content: IOBase, content_type: str):\n        self.filename = filename\n        self.content = content\n        self.content_type = content_type\n"})}),"\n",(0,s.jsx)(n.p,{children:"It is part of the generated client, and can be imported from it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from {target_package_name} import Upload\n"})}),"\n",(0,s.jsxs)(n.p,{children:["By default, this class represents the graphql scalar ",(0,s.jsx)(n.code,{children:"Upload"}),", but using custom scalar configuration, it can also be used for other scalars, e.g:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[tool.ariadne-codegen.scalars.OTHERSCALAR]\ntype = "Upload"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"pydantic-v2",children:"Pydantic v2"}),"\n",(0,s.jsxs)(n.p,{children:["Version ",(0,s.jsx)(n.code,{children:"0.8"})," changes the supported version of ",(0,s.jsx)(n.code,{children:"pydantic"})," to ",(0,s.jsx)(n.code,{children:">=2.0.0,<3.0.0"}),". List of changes in the generated client:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Renamed ",(0,s.jsx)(n.code,{children:"parse_obj"})," to ",(0,s.jsx)(n.code,{children:"model_validate"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Renamed ",(0,s.jsx)(n.code,{children:"dict"})," to ",(0,s.jsx)(n.code,{children:"model_dump"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Preconfigured ",(0,s.jsx)(n.code,{children:"BaseModel"})," uses ",(0,s.jsx)(n.code,{children:"model_config"})," attribute instead of ",(0,s.jsx)(n.code,{children:"Config"})," class."]}),"\n",(0,s.jsxs)(n.li,{children:["Renamed ",(0,s.jsx)(n.code,{children:"update_forward_refs"})," to ",(0,s.jsx)(n.code,{children:"model_rebuild"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Changed json encoder used by default base clients from ",(0,s.jsx)(n.code,{children:"pydantic.json.pydantic_encoder"})," to ",(0,s.jsx)(n.code,{children:"pydantic_core.to_jsonable_python"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Optional input fields now have an explicit default ",(0,s.jsx)(n.code,{children:"None"})," value (if the schema doesn't specify another value)."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"improved-custom-scalars",children:"Improved custom scalars"}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.code,{children:"0.8"}),", we removed custom scalar logic from the preconfigured ",(0,s.jsx)(n.code,{children:"BaseModel"}),", instead using pydantic's ",(0,s.jsx)(n.code,{children:"BeforeValidator"})," and ",(0,s.jsx)(n.code,{children:"PlainSerializer"}),". Now for every custom scalar provided in ",(0,s.jsx)(n.code,{children:"pyproject.toml"}),", we generate an annotation that is used in generated arguments, results, and input models."]}),"\n",(0,s.jsx)(n.p,{children:"Example of generated annotations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[tool.ariadne-codegen]\n...\nfiles_to_include = [".../type_b.py"]\n\n[tool.ariadne-codegen.scalars.SCALARA]\ntype = "str"\n\n[tool.ariadne-codegen.scalars.DATETIME]\ntype = "datetime.datetime"\n\n[tool.ariadne-codegen.scalars.SCALARB]\ntype = ".type_b.TypeB"\nparse = ".type_b.parse_b"\nserialize = ".type_b.serialize_b"\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:"# scalars.py\n\nfrom datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import BeforeValidator, PlainSerializer\n\nfrom .type_b import TypeB, parse_b, serialize_b\n\nSCALARA = str\nDATETIME = datetime\nSCALARB = Annotated[TypeB, PlainSerializer(serialize_b), BeforeValidator(parse_b)]\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"BaseModel"})," no longer depends on ",(0,s.jsx)(n.code,{children:"scalars.py"}),", so now we can customize file name through the ",(0,s.jsx)(n.code,{children:"scalars_module_name"})," option."]}),"\n",(0,s.jsxs)(n.p,{children:["Scalars file has complellty different structure, so we removed ",(0,s.jsx)(n.code,{children:"generate_scalars_parse_dict"})," and ",(0,s.jsx)(n.code,{children:"generate_scalars_serialize_dict"})," plugin hooks. Instead, we introduced ",(0,s.jsx)(n.code,{children:"generate_scalar_annotation"})," and ",(0,s.jsx)(n.code,{children:"generate_scalar_imports"})," hooks."]}),"\n",(0,s.jsx)(n.h2,{id:"mixin-directive",children:"Mixin directive"}),"\n",(0,s.jsxs)(n.p,{children:["Ariadne Codegen 0.8 brings support for using the ",(0,s.jsx)(n.code,{children:"mixin"})," directive on fragment definitions."]}),"\n",(0,s.jsx)(n.p,{children:"For example, given this fragment definition:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gql",children:'fragment fragmentA on TypeA @mixin(from: ".mixins", import: "MixinA") {\n  fieldA\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Generated ",(0,s.jsx)(n.code,{children:"FragmentA"})," will inherit from ",(0,s.jsx)(n.code,{children:"MixinA"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# fragments.py\n\nfrom .base_model import BaseModel\nfrom .mixins import MixinA\n\n\nclass FragmentA(BaseModel, MixinA):\n    field_a: int = Field(alias="fieldA")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, from now on, the ",(0,s.jsx)(n.code,{children:"mixin"})," directive will be excluded from the operation string, which is sent to a graphql server."]}),"\n",(0,s.jsx)(n.h2,{id:"field-names",children:"Field names"}),"\n",(0,s.jsxs)(n.p,{children:["Version ",(0,s.jsx)(n.code,{children:"0.8"})," introduces improvements in generating field names. It will append ",(0,s.jsx)(n.code,{children:"_"})," to generated field name that would be already reserved by pydantic ",(0,s.jsx)(n.code,{children:"BaseModel"}),"'s methods and attributes."]}),"\n",(0,s.jsxs)(n.p,{children:["We also added handling of field names which consist only of underscores. It will be generated as ",(0,s.jsx)(n.code,{children:"underscore_named_field_"}),". This behavior has the lowest priority in our name processing, so such a field's name can be altered by using an alias or utilizing ",(0,s.jsx)(n.code,{children:"process_name"})," plugin hook."]}),"\n",(0,s.jsx)(n.h2,{id:"unified-annotations",children:"Unified annotations"}),"\n",(0,s.jsxs)(n.p,{children:["We changed the generated client to use ",(0,s.jsx)(n.code,{children:"typing.Dict"})," and ",(0,s.jsx)(n.code,{children:"typing.List"})," instead of ",(0,s.jsx)(n.code,{children:"dict"})," and ",(0,s.jsx)(n.code,{children:"list"}),". That way, used annotations don't prevent using a generated client with older versions of Python."]}),"\n",(0,s.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Added support for ",(0,s.jsx)(n.code,{children:"Upload"})," scalar. Added support for file uploads to ",(0,s.jsx)(n.code,{children:"AsyncBaseClient"})," and ",(0,s.jsx)(n.code,{children:"BaseClient"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Added validation of defined operations against the schema."}),"\n",(0,s.jsxs)(n.li,{children:["Removed ",(0,s.jsx)(n.code,{children:"mixin"})," directive from fragment string included in operation string sent to server."]}),"\n",(0,s.jsxs)(n.li,{children:["Added support for ",(0,s.jsx)(n.code,{children:"mixin"})," directive on fragments definitions."]}),"\n",(0,s.jsx)(n.li,{children:"Added support for fragments defined on subtype of field's type."}),"\n",(0,s.jsx)(n.li,{children:"Added default representation for a field name consisting only of underscores."}),"\n",(0,s.jsx)(n.li,{children:"Changed generated client and models to use pydantic v2."}),"\n",(0,s.jsxs)(n.li,{children:["Changed custom scalars implementation to utilize pydantic's ",(0,s.jsx)(n.code,{children:"BeforeValidator"})," and ",(0,s.jsx)(n.code,{children:"PlainSerializer"}),". Added ",(0,s.jsx)(n.code,{children:"scalars_module_name"})," option. Replaced ",(0,s.jsx)(n.code,{children:"generate_scalars_parse_dict"})," and ",(0,s.jsx)(n.code,{children:"generate_scalars_serialize_dict"})," with ",(0,s.jsx)(n.code,{children:"generate_scalar_annotation"})," and ",(0,s.jsx)(n.code,{children:"generate_scalar_imports"})," plugin hooks."]}),"\n",(0,s.jsx)(n.li,{children:"Unified annotations in generated client to be compatible with python < 3.9."}),"\n",(0,s.jsx)(n.li,{children:"Fixed generating default values of input types from remote schemas."}),"\n",(0,s.jsxs)(n.li,{children:["Changed generating of input and result field names to add ",(0,s.jsx)(n.code,{children:"_"})," to names reserved by pydantic."]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},84429:function(e,n,i){i.d(n,{R:()=>r,x:()=>t});var d=i(96540);let s={},a=d.createContext(s);function r(e){let n=d.useContext(a);return d.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),d.createElement(a.Provider,{value:n},e.children)}},57445:function(e){e.exports=JSON.parse('{"permalink":"/blog/2023/08/22/ariadne-codegen-0-8","source":"@site/blog/2023-08-22-ariadne-codegen-0-8.md","title":"Ariadne Codegen 0.8","description":"Ariadne Codegen 0.8 has been released!","date":"2023-08-22T00:00:00.000Z","tags":[],"readingTime":3.37,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Ariadne Codegen 0.8"},"unlisted":false,"prevItem":{"title":"Ariadne Codegen 0.9","permalink":"/blog/2023/09/11/ariadne-codegen-0-9"},"nextItem":{"title":"GraphQL Gathering EU in Berlin","permalink":"/blog/2023/07/10/graphql-gathering"}}')}}]);