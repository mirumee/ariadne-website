"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["70255"],{94578:function(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var s=i(42061),a=i(74848),t=i(84429);let r={title:"Ariadne Codegen 0.9"},l,d={authorsImageUrls:[]},c=[{value:"Custom scalars",id:"custom-scalars",level:2},{value:"Custom scalar without custom parse and serialize",id:"custom-scalar-without-custom-parse-and-serialize",level:3},{value:"Custom scalar with custom parse and serialize",id:"custom-scalar-with-custom-parse-and-serialize",level:3},{value:"Pydantic`s warnings",id:"pydantics-warnings",level:2},{value:"Nullable directives",id:"nullable-directives",level:2},{value:"Operation string with nested inline fragments",id:"operation-string-with-nested-inline-fragments",level:2},{value:"Changelog",id:"changelog",level:2}];function o(e){let n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Ariadne Codegen 0.9 is now available!"}),"\n",(0,a.jsx)(n.p,{children:"This release includes a number of fixes and improvements related to Pydantic v2."}),"\n",(0,a.jsx)(n.h2,{id:"custom-scalars",children:"Custom scalars"}),"\n",(0,a.jsxs)(n.p,{children:["In the last refactoring of custom scalars, we introduced a bug that caused custom ",(0,a.jsx)(n.code,{children:"parse"})," to be called on already correct objects within generated input models. To fix this, we are again changing the way custom scalars are represented in the generated package. We are removing ",(0,a.jsx)(n.code,{children:"scalars.py"}),", the related option and plugin hooks. Instead, scalars will be represented directly as provided types."]}),"\n",(0,a.jsx)(n.h3,{id:"custom-scalar-without-custom-parse-and-serialize",children:"Custom scalar without custom parse and serialize"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-toml",children:'[tool.ariadne-codegen.scalars.SCALARA]\ntype = "str"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Each occurrence of ",(0,a.jsx)(n.code,{children:"SCALARA"})," is represented as ",(0,a.jsx)(n.code,{children:"str"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-toml",children:'[tool.ariadne-codegen.scalars.DATETIME]\ntype = "datetime.datetime"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In this case, ",(0,a.jsx)(n.code,{children:"DATETIME"})," is treated in the same way, but the necessary import is added: ",(0,a.jsx)(n.code,{children:"from datetime import datetime"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"custom-scalar-with-custom-parse-and-serialize",children:"Custom scalar with custom parse and serialize"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-toml",children:'[tool.ariadne-codegen]\n...\nfiles_to_include = [".../type_b.py"]\n\n[tool.ariadne-codegen.scalars.SCALARB]\ntype = ".type_b.TypeB"\nparse = ".type_b.parse_b"\nserialize = ".type_b.serialize_b"\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"SCALARB"})," is represented as ",(0,a.jsx)(n.code,{children:"TypeB"}),", but annotated according to its specific usage."]}),"\n",(0,a.jsxs)(n.p,{children:["In models representing input types it will be annotated with ",(0,a.jsx)(n.code,{children:"PlainSerializer"}),". This allows the user to create an input model with an existing ",(0,a.jsx)(n.code,{children:"TypeB"})," instance, and serialization will take place automatically during query execution."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# inputs.py\n\nclass TestInput(BaseModel):\n    value_b: Annotated[TypeB, PlainSerializer(serialize_b)]\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"b = TypeB(...)\ntest_input = TestInput(value_b=b)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In result models ",(0,a.jsx)(n.code,{children:"TypeB"})," will be annotated with ",(0,a.jsx)(n.code,{children:"BeforeValidator"}),", which will use ",(0,a.jsx)(n.code,{children:"parse_b"})," to deserialize ",(0,a.jsx)(n.code,{children:"TypeB"}),"`s data from the server."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# get_b.py\n\nclass GetB(BaseModel):\n    query_b: Annotated[TypeB, BeforeValidator(parse_b)]\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"async with Client(...) as client:\n    b_data = await client.get_b()\n\nassert isinstance(b_data.query_b, TypeB)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If ",(0,a.jsx)(n.code,{children:"SCALARB"})," is used as the type of the operation argument, it will be represented as an unannotated ",(0,a.jsx)(n.code,{children:"TypeB"}),", but ",(0,a.jsx)(n.code,{children:"serialize_b"})," will still be used in ",(0,a.jsx)(n.code,{children:"variables"})," dict."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:'# client.py\n\nclass Client(AsyncBaseClient):\n    async def test_mutation(self, value: TypeB) -> TestMutation:\n        ...\n        variables: Dict[str, object] = {\n            "value": serialize_b(value),\n        }\n        ...\n'})}),"\n",(0,a.jsx)(n.h2,{id:"pydantics-warnings",children:"Pydantic`s warnings"}),"\n",(0,a.jsxs)(n.p,{children:["By default, Pydantic gives a warning if the name of a field starts with ",(0,a.jsx)(n.code,{children:"model_"}),", but throws an error if there is a collision with an existing attribute. In the last release we took care of the collisions and now we are changing the configuration of ",(0,a.jsx)(n.code,{children:"BaseModel"})," to not give these warnings."]}),"\n",(0,a.jsx)(n.h2,{id:"nullable-directives",children:"Nullable directives"}),"\n",(0,a.jsxs)(n.p,{children:["Codegen detects ",(0,a.jsx)(n.code,{children:"@skip' and "}),"@include' directives and marks fields with them as ",(0,a.jsx)(n.code,{children:"Optional"}),", even if the type is not nullable. With pydantic v1 this worked fine, but with v2 there is an error if the response does not include a key for such a field. To maintain previous functionality, we will add an explicit ",(0,a.jsx)(n.code,{children:"None"})," default for fields with one of these directives."]}),"\n",(0,a.jsx)(n.h2,{id:"operation-string-with-nested-inline-fragments",children:"Operation string with nested inline fragments"}),"\n",(0,a.jsxs)(n.p,{children:["Version ",(0,a.jsx)(n.code,{children:"0.9"})," fixes the way we generate the operation string for the case where fragments are only used within an inline fragment. From now on we include these nested fragments."]}),"\n",(0,a.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Fixed generating operation string for nested inline fragments."}),"\n",(0,a.jsxs)(n.li,{children:["Removed scalars module. Changed generated models and client to use annotated types for custom scalars. Removed ",(0,a.jsx)(n.code,{children:"scalars_module_name"})," option. Removed ",(0,a.jsx)(n.code,{children:"generate_scalars_module"}),", ",(0,a.jsx)(n.code,{children:"generate_scalars_cod"}),", ",(0,a.jsx)(n.code,{children:"generate_scalar_annotation"})," and ",(0,a.jsx)(n.code,{children:"generate_scalar_imports"})," plugin hooks."]}),"\n",(0,a.jsxs)(n.li,{children:["Removed pydantic warnings for fields with ",(0,a.jsx)(n.code,{children:"model_"})," prefix."]}),"\n",(0,a.jsx)(n.li,{children:"Fixed generating result types with nullable directives."}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},84429:function(e,n,i){i.d(n,{R:()=>r,x:()=>l});var s=i(96540);let a={},t=s.createContext(a);function r(e){let n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(t.Provider,{value:n},e.children)}},42061:function(e){e.exports=JSON.parse('{"permalink":"/blog/2023/09/11/ariadne-codegen-0-9","source":"@site/blog/2023-09-11-ariadne-codegen-0-9.md","title":"Ariadne Codegen 0.9","description":"Ariadne Codegen 0.9 is now available!","date":"2023-09-11T00:00:00.000Z","tags":[],"readingTime":2.55,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Ariadne Codegen 0.9"},"unlisted":false,"prevItem":{"title":"Ariadne 0.21","permalink":"/blog/2023/11/08/ariadne-0-21-0"},"nextItem":{"title":"Ariadne Codegen 0.8","permalink":"/blog/2023/08/22/ariadne-codegen-0-8"}}')}}]);