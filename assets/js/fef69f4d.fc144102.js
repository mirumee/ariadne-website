"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["70950"],{69232:function(e,n,s){s.r(n),s.d(n,{frontMatter:()=>a,toc:()=>o,default:()=>p,metadata:()=>r,assets:()=>c,contentTitle:()=>l});var r=JSON.parse('{"id":"Docs/subscription-handlers","title":"Pluggable Subscription Handlers","description":"Ariadne provides a pluggable subscription handler system for GraphQLHTTPHandler that allows implementing custom HTTP-based transport protocols for GraphQL subscriptions. This enables support for delivery mechanisms like Server-Sent Events (SSE), HTTP callbacks, and custom protocols.","source":"@site/server_versioned_docs/version-0.29.0/01-Docs/24-subscription-handlers.md","sourceDirName":"01-Docs","slug":"/Docs/subscription-handlers","permalink":"/server/Docs/subscription-handlers","draft":false,"unlisted":false,"tags":[],"version":"0.29.0","sidebarPosition":24,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Synchronous Generator Subscriptions","permalink":"/server/Docs/sync-subscriptions"},"next":{"title":"OpenTelemetry","permalink":"/server/Monitoring/open-telemetry"}}'),t=s(74848),i=s(84429);let a={},l="Pluggable Subscription Handlers",c={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Using Subscription Handlers",id:"using-subscription-handlers",level:2},{value:"Basic Setup",id:"basic-setup",level:3},{value:"Handler Selection",id:"handler-selection",level:3},{value:"Creating Custom Handlers",id:"creating-custom-handlers",level:2},{value:"The SubscriptionHandler Base Class",id:"the-subscriptionhandler-base-class",level:3},{value:"The generate_events() Method",id:"the-generate_events-method",level:3},{value:"Event System",id:"event-system",level:2},{value:"SubscriptionEventType",id:"subscriptioneventtype",level:3},{value:"SubscriptionEvent",id:"subscriptionevent",level:3},{value:"Processing Events",id:"processing-events",level:3},{value:"HTTP Callback Handler Example",id:"http-callback-handler-example",level:2},{value:"Use Case",id:"use-case",level:3},{value:"Message Types",id:"message-types",level:3},{value:"Request Format",id:"request-format",level:3},{value:"Callback Payloads",id:"callback-payloads",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Usage",id:"usage",level:3},{value:"Combining Multiple Handlers",id:"combining-multiple-handlers",level:2},{value:"Selection Logic Examples",id:"selection-logic-examples",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Resource Cleanup",id:"1-resource-cleanup",level:3},{value:"2. Error Handling",id:"2-error-handling",level:3},{value:"3. Keep-Alive for Long Connections",id:"3-keep-alive-for-long-connections",level:3},{value:"4. Background Tasks",id:"4-background-tasks",level:3},{value:"5. Termination Handling",id:"5-termination-handling",level:3},{value:"Summary",id:"summary",level:2}];function d(e){let n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"pluggable-subscription-handlers",children:"Pluggable Subscription Handlers"})}),"\n",(0,t.jsxs)(n.p,{children:["Ariadne provides a pluggable subscription handler system for ",(0,t.jsx)(n.code,{children:"GraphQLHTTPHandler"})," that allows implementing custom HTTP-based transport protocols for GraphQL subscriptions. This enables support for delivery mechanisms like Server-Sent Events (SSE), HTTP callbacks, and custom protocols."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," WebSocket-based subscriptions are handled separately by dedicated handlers (",(0,t.jsx)(n.code,{children:"GraphQLWSHandler"})," and ",(0,t.jsx)(n.code,{children:"GraphQLTransportWSHandler"}),"). The pluggable subscription handler system described here is specifically for HTTP-based subscription transports configured via the ",(0,t.jsx)(n.code,{children:"subscription_handlers"})," parameter of ",(0,t.jsx)(n.code,{children:"GraphQLHTTPHandler"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#using-subscription-handlers",children:"Using Subscription Handlers"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#creating-custom-handlers",children:"Creating Custom Handlers"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#event-system",children:"Event System"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#http-callback-handler-example",children:"HTTP Callback Handler Example"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#combining-multiple-handlers",children:"Combining Multiple Handlers"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The subscription handler system uses the ",(0,t.jsx)(n.strong,{children:"Strategy Pattern"})," to decouple subscription execution from transport delivery. Each handler:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Determines support"}),": Checks if it can handle a given request (via ",(0,t.jsx)(n.code,{children:"supports()"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handles the request"}),": Processes the subscription and delivers events (via ",(0,t.jsx)(n.code,{children:"handle()"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Generates events"}),": Uses the shared ",(0,t.jsx)(n.code,{children:"generate_events()"})," method to execute the subscription"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"HTTP Request \u2192 GraphQLHTTPHandler\n                    \u2193\n              subscription_handlers[0].supports(request, data)?\n                    \u2193 Yes                    \u2193 No\n              handler.handle()         Try next handler...\n                    \u2193                        \u2193 No handlers match\n              generate_events()        Normal query/mutation execution\n                    \u2193\n              SubscriptionEvent stream\n                    \u2193\n              Transport-specific delivery (SSE, HTTP callback, etc.)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"using-subscription-handlers",children:"Using Subscription Handlers"}),"\n",(0,t.jsx)(n.h3,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,t.jsxs)(n.p,{children:["Pass subscription handlers to ",(0,t.jsx)(n.code,{children:"GraphQLHTTPHandler"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from ariadne.asgi import GraphQL\nfrom ariadne.asgi.handlers import GraphQLHTTPHandler\n\nfrom myapp.handlers import MySubscriptionHandler\n\napp = GraphQL(\n    schema,\n    http_handler=GraphQLHTTPHandler(\n        subscription_handlers=[\n            MySubscriptionHandler(),\n        ]\n    ),\n)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"handler-selection",children:"Handler Selection"}),"\n",(0,t.jsxs)(n.p,{children:["When a subscription request arrives, handlers are checked in order. The first handler whose ",(0,t.jsx)(n.code,{children:"supports()"})," method returns ",(0,t.jsx)(n.code,{children:"True"})," handles the request."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"http_handler=GraphQLHTTPHandler(\n    subscription_handlers=[\n        MyCustomHandler(),      # Checked first\n        SSESubscriptionHandler(),  # Fallback\n    ]\n)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"creating-custom-handlers",children:"Creating Custom Handlers"}),"\n",(0,t.jsx)(n.h3,{id:"the-subscriptionhandler-base-class",children:"The SubscriptionHandler Base Class"}),"\n",(0,t.jsxs)(n.p,{children:["Custom handlers extend ",(0,t.jsx)(n.code,{children:"SubscriptionHandler"})," and implement two methods:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from ariadne.subscription_handlers import SubscriptionHandler\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\n\nclass MyCustomHandler(SubscriptionHandler):\n    def supports(self, request: Request, data: dict) -> bool:\n        """Return True if this handler should process the request."""\n        # Check headers, extensions, or request data\n        return "myCustomHeader" in request.headers\n\n    async def handle(\n        self,\n        request: Request,\n        data: dict,\n        *,\n        schema,\n        context_value,\n        root_value,\n        query_parser,\n        query_validator,\n        validation_rules,\n        debug,\n        introspection,\n        logger,\n        error_formatter,\n    ) -> Response:\n        """Process the subscription and return a response."""\n        # Use generate_events() to get subscription events\n        async for event in self.generate_events(\n            data,\n            schema=schema,\n            context_value=context_value,\n            root_value=root_value,\n            query_parser=query_parser,\n            query_validator=query_validator,\n            query_document=None,\n            validation_rules=validation_rules,\n            debug=debug,\n            introspection=introspection,\n            logger=logger,\n            error_formatter=error_formatter,\n        ):\n            # Process each SubscriptionEvent\n            # event.event_type: NEXT, ERROR, COMPLETE, KEEP_ALIVE\n            # event.result: ExecutionResult (for NEXT/ERROR events)\n            pass\n\n        return Response(status_code=200)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"the-generate_events-method",children:"The generate_events() Method"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"generate_events()"})," method is provided by ",(0,t.jsx)(n.code,{children:"SubscriptionHandler"})," and handles:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Request validation"}),"\n",(0,t.jsx)(n.li,{children:"GraphQL subscription execution"}),"\n",(0,t.jsx)(n.li,{children:"Error handling and formatting"}),"\n",(0,t.jsxs)(n.li,{children:["Yielding ",(0,t.jsx)(n.code,{children:"SubscriptionEvent"})," objects"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"You don't need to implement subscription execution logic\u2014just consume the events and deliver them via your transport."}),"\n",(0,t.jsx)(n.h2,{id:"event-system",children:"Event System"}),"\n",(0,t.jsx)(n.h3,{id:"subscriptioneventtype",children:"SubscriptionEventType"}),"\n",(0,t.jsx)(n.p,{children:"Events have one of four types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from ariadne.subscription_handlers.events import SubscriptionEventType\n\nSubscriptionEventType.NEXT       # Contains subscription data\nSubscriptionEventType.ERROR      # Contains error information\nSubscriptionEventType.COMPLETE   # Subscription ended normally\nSubscriptionEventType.KEEP_ALIVE # Connection maintenance\n"})}),"\n",(0,t.jsx)(n.h3,{id:"subscriptionevent",children:"SubscriptionEvent"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from ariadne.subscription_handlers.events import (\n    SubscriptionEvent,\n    SubscriptionEventType,\n)\nfrom graphql import ExecutionResult\n\n# Create events using direct construction\nevent = SubscriptionEvent(\n    event_type=SubscriptionEventType.NEXT,\n    result=execution_result,\n)\nevent = SubscriptionEvent(\n    event_type=SubscriptionEventType.ERROR,\n    result=execution_result,\n)\nevent = SubscriptionEvent(event_type=SubscriptionEventType.COMPLETE)\nevent = SubscriptionEvent(event_type=SubscriptionEventType.KEEP_ALIVE)\n\n# Access event data\nevent.event_type  # SubscriptionEventType\nevent.result      # ExecutionResult or None\n"})}),"\n",(0,t.jsx)(n.h3,{id:"processing-events",children:"Processing Events"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"async for event in self.generate_events(data, **kwargs):\n    if event.event_type == SubscriptionEventType.NEXT:\n        # event.result.data contains the subscription payload\n        # event.result.errors may contain GraphQL errors\n        pass\n\n    elif event.event_type == SubscriptionEventType.ERROR:\n        # Handle error - event.result.errors contains error details\n        pass\n\n    elif event.event_type == SubscriptionEventType.COMPLETE:\n        # Subscription finished - clean up resources\n        break\n\n    elif event.event_type == SubscriptionEventType.KEEP_ALIVE:\n        # Send keep-alive signal to client\n        pass\n"})}),"\n",(0,t.jsx)(n.h2,{id:"http-callback-handler-example",children:"HTTP Callback Handler Example"}),"\n",(0,t.jsx)(n.p,{children:"This example shows how to implement a subscription handler for gateway architectures where events are delivered via HTTP callbacks instead of persistent connections."}),"\n",(0,t.jsx)(n.h3,{id:"use-case",children:"Use Case"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Client \u2500\u2500SSE\u2500\u2500> Gateway \u2500\u2500HTTP POST\u2500\u2500> GraphQL Server (DGS)\n                   \u2191                          \u2502\n                   \u2514\u2500\u2500\u2500\u2500HTTP callbacks\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Client connects to gateway via SSE"}),"\n",(0,t.jsxs)(n.li,{children:["Gateway forwards subscription to DGS with a ",(0,t.jsx)(n.code,{children:"callbackUri"})]}),"\n",(0,t.jsx)(n.li,{children:"DGS returns 204 immediately"}),"\n",(0,t.jsx)(n.li,{children:"DGS posts events (DATA, KEEP_ALIVE, COMPLETE, CLOSE) to the callback URI"}),"\n",(0,t.jsx)(n.li,{children:"Gateway streams events to client"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"message-types",children:"Message Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from enum import Enum\n\n\nclass MessageType(str, Enum):\n    KEEP_ALIVE = "KEEP_ALIVE"  # Heartbeat\n    DATA = "DATA"              # Subscription data\n    COMPLETE = "COMPLETE"      # Normal completion\n    CLOSE = "CLOSE"            # Error/early termination\n\n\nclass ResultStatus(str, Enum):\n    ACCEPTED = "ACCEPTED"           # Message accepted\n    SUCCESS = "SUCCESS"             # Delivered to client\n    IO_EXCEPTION = "IO_EXCEPTION"   # I/O error\n    CONNECTION_CLOSED = "CONNECTION_CLOSED"  # Client disconnected\n    NOT_FOUND = "NOT_FOUND"         # Unknown subscription ID\n'})}),"\n",(0,t.jsx)(n.h3,{id:"request-format",children:"Request Format"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "query": "subscription { counter }",\n    "extensions": {\n        "subscription": {\n            "callbackUri": "https://gateway.example.com/callback",\n            "subscriptionId": "uuid-here",\n            "callbackAppId": "my-app"\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"callback-payloads",children:"Callback Payloads"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"KEEP_ALIVE:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "subscriptionId": "uuid-here",\n    "type": "KEEP_ALIVE"\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"DATA:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "subscriptionId": "uuid-here",\n    "type": "DATA",\n    "data": {\n        "counter": 42\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"COMPLETE:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "subscriptionId": "uuid-here",\n    "type": "COMPLETE"\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLOSE (with error):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "subscriptionId": "uuid-here",\n    "type": "CLOSE",\n    "errors": [{"message": "Subscription error: ..."}]\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.code,{children:"examples/subscription_handler_example.py"})," for a complete implementation that includes:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Metadata extraction from request extensions"}),"\n",(0,t.jsxs)(n.li,{children:["Background task execution using Starlette's ",(0,t.jsx)(n.code,{children:"BackgroundTask"})]}),"\n",(0,t.jsx)(n.li,{children:"Periodic keep-alive messages"}),"\n",(0,t.jsx)(n.li,{children:"Retry logic for failed callbacks"}),"\n",(0,t.jsx)(n.li,{children:"Early termination based on gateway response status"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from ariadne.asgi import GraphQL\nfrom ariadne.asgi.handlers import GraphQLHTTPHandler\n\nfrom myapp.handlers import CallbackSubscriptionHandler\n\napp = GraphQL(\n    schema,\n    http_handler=GraphQLHTTPHandler(\n        subscription_handlers=[\n            CallbackSubscriptionHandler(\n                keep_alive_interval=5.0,\n                callback_timeout=10.0,\n                max_retries=3,\n            )\n        ]\n    ),\n)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"combining-multiple-handlers",children:"Combining Multiple Handlers"}),"\n",(0,t.jsx)(n.p,{children:"You can combine multiple handlers to support different clients:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from ariadne.asgi import GraphQL\nfrom ariadne.asgi.handlers import GraphQLHTTPHandler\nfrom ariadne.contrib.sse import SSESubscriptionHandler\n\nfrom myapp.handlers import CallbackSubscriptionHandler\n\napp = GraphQL(\n    schema,\n    http_handler=GraphQLHTTPHandler(\n        subscription_handlers=[\n            # Gateway requests with callbackUri\n            CallbackSubscriptionHandler(),\n            # Browser clients with Accept: text/event-stream\n            SSESubscriptionHandler(),\n        ]\n    ),\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Handler selection order matters"}),"\u2014the first matching handler processes the request."]}),"\n",(0,t.jsx)(n.h3,{id:"selection-logic-examples",children:"Selection Logic Examples"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Request"}),(0,t.jsx)(n.th,{children:"Handler Selected"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"extensions.subscription.callbackUri"})," present"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"CallbackSubscriptionHandler"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"Accept: text/event-stream"})," header"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"SSESubscriptionHandler"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Neither"}),(0,t.jsx)(n.td,{children:"Falls through to HTTP handler"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-resource-cleanup",children:"1. Resource Cleanup"}),"\n",(0,t.jsx)(n.p,{children:"Always clean up resources when the subscription ends:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"async def handle(self, request, data, **kwargs):\n    try:\n        async for event in self.generate_events(data, **kwargs):\n            # Process events\n            pass\n    finally:\n        # Cleanup: close connections, cancel tasks, etc.\n        pass\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-error-handling",children:"2. Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"Handle errors gracefully and send appropriate error events to clients:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"async def handle(self, request, data, **kwargs):\n    try:\n        async for event in self.generate_events(data, **kwargs):\n            await self.deliver_event(event)\n    except Exception as e:\n        # Send error to client before closing\n        await self.send_error(str(e))\n        raise\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-keep-alive-for-long-connections",children:"3. Keep-Alive for Long Connections"}),"\n",(0,t.jsx)(n.p,{children:"For persistent connections, send periodic keep-alive signals:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import asyncio\n\n\nasync def handle(self, request, data, **kwargs):\n    keep_alive_task = asyncio.create_task(self.send_keep_alive())\n\n    try:\n        async for event in self.generate_events(data, **kwargs):\n            await self.deliver_event(event)\n    finally:\n        keep_alive_task.cancel()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-background-tasks",children:"4. Background Tasks"}),"\n",(0,t.jsxs)(n.p,{children:["For fire-and-forget delivery (like HTTP callbacks), use Starlette's ",(0,t.jsx)(n.code,{children:"BackgroundTask"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from starlette.background import BackgroundTask\nfrom starlette.responses import Response\n\n\nasync def handle(self, request, data, **kwargs):\n    return Response(\n        status_code=204,\n        background=BackgroundTask(\n            self._execute_subscription,\n            data=data,\n            **kwargs,\n        ),\n    )\n"})}),"\n",(0,t.jsx)(n.h3,{id:"5-termination-handling",children:"5. Termination Handling"}),"\n",(0,t.jsx)(n.p,{children:"Respond to client disconnection or termination signals:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"async def _execute_subscription(self, data, **kwargs):\n    terminated = False\n\n    async for event in self.generate_events(data, **kwargs):\n        response = await self.deliver_event(event)\n\n        if self.should_terminate(response):\n            terminated = True\n            break\n\n    if not terminated:\n        await self.send_complete()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"The pluggable subscription handler system provides:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Flexibility"}),": Implement any transport protocol"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reusability"}),": Share subscription execution logic via ",(0,t.jsx)(n.code,{children:"generate_events()"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Composability"}),": Combine multiple handlers for different clients"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Clean separation"}),": Transport concerns separated from GraphQL execution"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Ariadne is transport-agnostic\u2014implement custom handlers for your specific needs: SSE for browser clients, HTTP callbacks for gateway architectures, or any other delivery mechanism. See ",(0,t.jsx)(n.code,{children:"examples/subscription_handler_example.py"})," for a complete reference implementation."]})]})}function p(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},84429:function(e,n,s){s.d(n,{R:()=>a,x:()=>l});var r=s(96540);let t={},i=r.createContext(t);function a(e){let n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);