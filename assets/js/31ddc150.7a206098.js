"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["47521"],{11625:function(e,n,r){r.r(n),r.d(n,{frontMatter:()=>s,toc:()=>d,default:()=>p,metadata:()=>a,assets:()=>c,contentTitle:()=>i});var a=JSON.parse('{"id":"query-stack","title":"Customizing Query Stack","description":"Ariadne lets to developers to replace both parsing and validating steps of the query execution stack with custom logic.","source":"@site/server_versioned_docs/version-0.22/query-stack.md","sourceDirName":".","slug":"/query-stack","permalink":"/server/0.22/query-stack","draft":false,"unlisted":false,"tags":[],"version":"0.22","frontMatter":{"id":"query-stack","title":"Customizing Query Stack"},"sidebar":"tutorialSidebar","previous":{"title":"Query validators","permalink":"/server/0.22/query-validators"},"next":{"title":"ariadne","permalink":"/server/0.22/api-reference"}}'),t=r(74848),o=r(84429);let s={id:"query-stack",title:"Customizing Query Stack"},i,c={},d=[{value:"Query parser",id:"query-parser",level:2},{value:"Query validation",id:"query-validation",level:2},{value:"Examples",id:"examples",level:2},{value:"Caching parsed queries",id:"caching-parsed-queries",level:3},{value:"Combined parse and validation cache",id:"combined-parse-and-validation-cache",level:3}];function l(e){let n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Ariadne lets to developers to replace both parsing and validating steps of the query execution stack with custom logic."}),"\n",(0,t.jsx)(n.h2,{id:"query-parser",children:"Query parser"}),"\n",(0,t.jsxs)(n.p,{children:["Default GraphQL query parser used by Ariadne is the ",(0,t.jsx)(n.code,{children:"parse"})," function from the ",(0,t.jsx)(n.code,{children:"graphql-core"})," package:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from graphql import parse\n\ndocument = parse("{ query string }")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This function takes the ",(0,t.jsx)(n.code,{children:"str"})," with the GraphQL query, and parsers it into a ",(0,t.jsx)(n.code,{children:"DocumentNode"})," instance containing the GraphQL AST representation of the query."]}),"\n",(0,t.jsxs)(n.p,{children:["Ariadne's ",(0,t.jsx)(n.code,{children:"GraphQL()"})," ASGI and WSGI apps together with ",(0,t.jsx)(n.code,{children:"graphql()"}),", ",(0,t.jsx)(n.code,{children:"graphql_sync()"})," and ",(0,t.jsx)(n.code,{children:"subscribe()"})," functions accept the ",(0,t.jsx)(n.code,{children:"query_parser"})," named argument that lets server developers to provide a custom function to use for parsing queries."]}),"\n",(0,t.jsx)(n.p,{children:"If custom parser is set, this parser is called with two arguments:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"context: ContextValue"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data: dict[str, Any]"}),": a ",(0,t.jsx)(n.code,{children:"dict"})," with current operation's payload (",(0,t.jsx)(n.code,{children:"query"}),", ",(0,t.jsx)(n.code,{children:"operationName"})," and ",(0,t.jsx)(n.code,{children:"variables"}),")."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Here's an example custom parser function that only parses the ",(0,t.jsx)(n.code,{children:"query"})," string from query's payload:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from ariadne.types import ContextValue\nfrom graphql import DocumentNode, parse\n\n\ndef caching_query_parser(context: ContextValue, data: dict[str, Any]) -> DocumentNode:\n    return parse(data["query"])\n'})}),"\n",(0,t.jsx)(n.h2,{id:"query-validation",children:"Query validation"}),"\n",(0,t.jsxs)(n.p,{children:["Ariadne's GraphQL query validation uses the ",(0,t.jsx)(n.code,{children:"validate"})," function from the ",(0,t.jsx)(n.code,{children:"graphql-core"})," package to validate a query against a schema and a set of rules. This function can be swapped out in GraphQL servers using the ",(0,t.jsx)(n.code,{children:"query_validator"})," option."]}),"\n",(0,t.jsx)(n.p,{children:"Custom validator should have a following signature:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from typing import Collection, Type\n\nfrom graphql import (\n    GraphQLSchema,\n    DocumentNode,\n    ASTValidationRule,\n    TypeInfo,\n)\n\n\ndef custom_query_validator(\n    schema: GraphQLSchema,\n    document_ast: DocumentNode,\n    rules: Collection[Type[ASTValidationRule]] | None = None,\n    max_errors: int | None = None,\n    type_info: TypeInfo | None = None,\n) -> list[GraphQLError]:\n    return []  # List of `GraphQLError`s with problems with the query\n"})}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.h3,{id:"caching-parsed-queries",children:"Caching parsed queries"}),"\n",(0,t.jsx)(n.p,{children:"Following example shows a custom query parser that caches a number of GraphQL queries using the LRU approach. This parser will raise memory usage of the GraphQL server, but will improve query response times:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from functools import lru_cache\n\nfrom ariadne.types import ContextValue\nfrom graphql import DocumentNode, parse\n\n\nparse_cached = lru_cache(maxsize=64)(parse)\n\n\ndef caching_query_parser(context: ContextValue, data: dict[str, Any]) -> DocumentNode:\n    # Custom parser function is called with the context and entire query's payload.\n    return parse_cached(data[\"query\"])\n\n\n# Pass the 'caching_query_parser' to the 'query_parser' option of the 'GraphQL'\ngraphql = GraphQL(schema, query_parser=caching_query_parser)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"combined-parse-and-validation-cache",children:"Combined parse and validation cache"}),"\n",(0,t.jsx)(n.p,{children:"The below code combines custom parser and validator functions to add caching to both query parsing and validation parts of the Query Stack:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from collections.abc import Collection\nfrom functools import lru_cache\nfrom typing import Any\n\nfrom ariadne import make_executable_schema\nfrom ariadne.asgi import GraphQL\nfrom ariadne.graphql import validate_query\nfrom ariadne.types import ContextValue\nfrom graphql import ASTValidationRule, DocumentNode, GraphQLError, GraphQLSchema, TypeInfo, parse\n\n\nparse_cached = lru_cache(maxsize=64)(parse)\n\n\ndef caching_query_parser(context: ContextValue, data: dict[str, Any]) -> DocumentNode:\n    # Custom parser function is called with the context and entire query\'s payload.\n    return parse_cached(data["query"])\n\n\nvalidate_query_cached = lru_cache(maxsize=64)(validate_query)\n\n\ndef caching_query_validator(\n    schema: GraphQLSchema,\n    document_ast: DocumentNode,\n    rules: Collection[type[ASTValidationRule]] | None = None,\n    max_errors: int | None = None,\n    type_info: TypeInfo | None = None,\n) -> list[GraphQLError]:\n    return validate_query_cached(\n        schema=schema,\n        document_ast=document_ast,\n    )\n\n\n# Add type definitions, resolvers, etc...\nschema = make_executable_schema("...")\n\n# Using our custom functions for parsing & validation\ngraphql = GraphQL(\n    schema,\n    query_parser=caching_query_parser,\n    query_validator=caching_query_validator,\n)\n'})})]})}function p(e={}){let{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},84429:function(e,n,r){r.d(n,{R:()=>s,x:()=>i});var a=r(96540);let t={},o=a.createContext(t);function s(e){let n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);