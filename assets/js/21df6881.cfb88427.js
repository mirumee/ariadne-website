"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["9502"],{57704:function(e,r,s){s.r(r),s.d(r,{frontMatter:()=>i,toc:()=>c,default:()=>h,metadata:()=>n,assets:()=>o,contentTitle:()=>l});var n=JSON.parse('{"id":"scalars","title":"Custom scalars","description":"Custom scalars allow you to convert your Python objects to a JSON-serializable form in query results, as well as convert those JSON forms back to Python objects when they are passed as arguments or input values.","source":"@site/server_versioned_docs/version-0.10.0/scalars.md","sourceDirName":".","slug":"/scalars","permalink":"/server/0.10.0/scalars","draft":false,"unlisted":false,"tags":[],"version":"0.10.0","frontMatter":{"id":"scalars","title":"Custom scalars"},"sidebar":"tutorialSidebar","previous":{"title":"Error messaging","permalink":"/server/0.10.0/error-messaging"},"next":{"title":"Enumeration types","permalink":"/server/0.10.0/enums"}}'),a=s(74848),t=s(84429);let i={id:"scalars",title:"Custom scalars"},l,o={},c=[{value:"Example read-only scalar",id:"example-read-only-scalar",level:2},{value:"Scalars as input",id:"scalars-as-input",level:2},{value:"Configuration reference",id:"configuration-reference",level:2}];function d(e){let r={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(r.p,{children:["Custom scalars allow you to convert your Python objects to a JSON-serializable form in query results, as well as convert those JSON forms back to Python objects when they are passed as arguments or ",(0,a.jsx)(r.code,{children:"input"})," values."]}),"\n",(0,a.jsx)(r.h2,{id:"example-read-only-scalar",children:"Example read-only scalar"}),"\n",(0,a.jsxs)(r.p,{children:["Consider this API defining a ",(0,a.jsx)(r.code,{children:"Story"})," type with a ",(0,a.jsx)(r.code,{children:"publishedOn"})," field:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-graphql",children:"type Story {\n    content: String\n    publishedOn: String\n}\n"})}),"\n",(0,a.jsxs)(r.p,{children:["The ",(0,a.jsx)(r.code,{children:"publishedOn"})," field resolver returns an instance of type ",(0,a.jsx)(r.code,{children:"datetime"}),", but in the API this field is defined as ",(0,a.jsx)(r.code,{children:"String"}),". This means that our datetime will be passed through the ",(0,a.jsx)(r.code,{children:"str()"})," function before being returned to the client:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-json",children:'{\n    "publishedOn": "2018-10-26 17:28:54.416434"\n}\n'})}),"\n",(0,a.jsx)(r.p,{children:"This may look acceptable, but there are better formats to serialize timestamps for later deserialization on the client, like ISO 8601. This conversion could be performed in a dedicated resolver:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:"def resolve_published_on(obj, *_):\n    return obj.published_on.isoformat()\n"})}),"\n",(0,a.jsxs)(r.p,{children:["However, the developer now has to remember to define a custom resolver for every field that returns ",(0,a.jsx)(r.code,{children:"datetime"}),". This really adds boilerplate to the API, and makes it harder to use abstractions auto-generating the resolvers for you."]}),"\n",(0,a.jsx)(r.p,{children:"Instead, GraphQL API can be told how to serialize dates by defining the custom scalar type:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-graphql",children:"type Story {\n    content: String\n    publishedOn: Datetime\n}\n\nscalar Datetime\n"})}),"\n",(0,a.jsx)(r.p,{children:"If you try to query this field now, you will get an error:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-json",children:'{\n    "error": "Unexpected token A in JSON at position 0"\n}\n'})}),"\n",(0,a.jsxs)(r.p,{children:["This is because a custom scalar has been defined, but it's currently missing logic for serializing Python values to JSON form and ",(0,a.jsx)(r.code,{children:"Datetime"})," instances are not JSON serializable by default."]}),"\n",(0,a.jsxs)(r.p,{children:["We need to add a special serializing resolver to our ",(0,a.jsx)(r.code,{children:"Datetime"})," scalar that will implement the logic we are expecting. Ariadne provides the ",(0,a.jsx)(r.code,{children:"ScalarType"})," class that enables just that:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:'from ariadne import ScalarType\n\ndatetime_scalar = ScalarType("Datetime")\n\n@datetime_scalar.serializer\ndef serialize_datetime(value):\n    return value.isoformat()\n'})}),"\n",(0,a.jsxs)(r.p,{children:["Include the ",(0,a.jsx)(r.code,{children:"datetime_scalar"})," in the list of ",(0,a.jsx)(r.code,{children:"resolvers"})," passed to your GraphQL server. Custom serialization logic will now be used when a resolver for the ",(0,a.jsx)(r.code,{children:"Datetime"})," field returns a value other than ",(0,a.jsx)(r.code,{children:"None"}),":"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-json",children:'{\n    "publishedOn": "2018-10-26T17:45:08.805278"\n}\n'})}),"\n",(0,a.jsxs)(r.p,{children:["We can now reuse our custom scalar across the API to serialize ",(0,a.jsx)(r.code,{children:"datetime"})," instances in a standardized format that our clients will understand."]}),"\n",(0,a.jsx)(r.h2,{id:"scalars-as-input",children:"Scalars as input"}),"\n",(0,a.jsxs)(r.p,{children:["What will happen if now we create a field or mutation that defines an argument of the type ",(0,a.jsx)(r.code,{children:"Datetime"}),"? We can find out using a basic resolver:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-graphql",children:"type Query {\n    stories(publishedOn: Datetime): [Story!]!\n}\n"})}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:'def resolve_stories(*_, **data):\n    print(data.get("publishedOn"))  # what value will "publishedOn" be?\n'})}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.code,{children:'data.get("publishedOn")'})," will print whatever value was passed to the argument, coerced to the respective Python type. For some scalars this may do the trick, but for this one it's expected that input gets converted back to the ",(0,a.jsx)(r.code,{children:"datetime"})," instance."]}),"\n",(0,a.jsxs)(r.p,{children:["To turn our ",(0,a.jsx)(r.em,{children:"read-only"})," scalar into ",(0,a.jsx)(r.em,{children:"bidirectional"})," scalar, we will need to add two functions to the ",(0,a.jsx)(r.code,{children:"ScalarType"})," that was created in the previous step:"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.code,{children:"value_parser(value)"})," that will be used when the scalar value is passed as part of query ",(0,a.jsx)(r.code,{children:"variables"}),"."]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.code,{children:"literal_parser(ast)"})," that will be used when the scalar value is passed as part of query content (e.g. ",(0,a.jsx)(r.code,{children:'{ stories(publishedOn: "2018-10-26T17:45:08.805278") { ... } }'}),")."]}),"\n"]}),"\n",(0,a.jsx)(r.p,{children:"Those functions can be implemented as such:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:"@datetime_scalar.value_parser\ndef parse_datetime_value(value):\n    # dateutil is provided by python-dateutil library\n    if value:\n        return dateutil.parser.parse(value)\n\n@datetime_scalar.literal_parser\ndef parse_datetime_literal(ast):\n    value = str(ast.value)\n    return parse_datetime_value(value)  # reuse logic from parse_value\n"})}),"\n",(0,a.jsx)(r.p,{children:"There are a few things happening in the above code, so let's go through it step by step:"}),"\n",(0,a.jsxs)(r.p,{children:["If the ",(0,a.jsx)(r.code,{children:"value"})," is passed as part of a query's ",(0,a.jsx)(r.code,{children:"variables"}),", it's passed to ",(0,a.jsx)(r.code,{children:"parse_datetime_value"}),"."]}),"\n",(0,a.jsxs)(r.p,{children:["If the ",(0,a.jsx)(r.code,{children:"value"})," is not empty, ",(0,a.jsx)(r.code,{children:"dateutil.parser.parse"})," is used to parse it to the valid Python ",(0,a.jsx)(r.code,{children:"datetime"})," object instance that is then returned."]}),"\n",(0,a.jsxs)(r.p,{children:["If ",(0,a.jsx)(r.code,{children:"value"})," is incorrect and either a ",(0,a.jsx)(r.code,{children:"ValueError"})," or ",(0,a.jsx)(r.code,{children:"TypeError"})," exception is raised by the ",(0,a.jsx)(r.code,{children:"dateutil.parser.parse"}),", the GraphQL server interprets this as a sign that the entered value is incorrect because it can't be transformed to an internal representation and returns an automatically generated error message to the client that consists of two parts:"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["A message from GraphQL: ",(0,a.jsx)(r.code,{children:'Expected type Datetime!, found "invalid string"'})]}),"\n",(0,a.jsxs)(r.li,{children:["The internal exception message: ",(0,a.jsx)(r.code,{children:"time data 'invalid string' does not match format '%Y-%m-%d'"})]}),"\n"]}),"\n",(0,a.jsx)(r.p,{children:"The complete error message returned by the API will look like this:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"Expected type Datetime!, found \"invalid string\"; time data 'invalid string' does not match format '%Y-%m-%d'\n"})}),"\n",(0,a.jsxs)(r.blockquote,{children:["\n",(0,a.jsxs)(r.p,{children:["You can raise either ",(0,a.jsx)(r.code,{children:"ValueError"})," or ",(0,a.jsx)(r.code,{children:"TypeError"})," in your parsers."]}),"\n"]}),"\n",(0,a.jsxs)(r.blockquote,{children:["\n",(0,a.jsxs)(r.p,{children:["Because the error message returned by the GraphQL server includes the original exception message from your Python code, it may contain details specific to your system or implementation that you may not want to make known to the API consumers. You may decide to catch the original exception with ",(0,a.jsx)(r.code,{children:"except (ValueError, TypeError)"})," and then raise your own ",(0,a.jsx)(r.code,{children:"ValueError"})," with a custom message (or no message at all) to prevent this from happening."]}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:["If a value is specified as part of query content, its ",(0,a.jsx)(r.code,{children:"ast"})," node is instead passed to ",(0,a.jsx)(r.code,{children:"parse_datetime_literal"})," to give the scalar a chance to introspect the type of the node (implementations for those be found ",(0,a.jsx)(r.a,{href:"https://github.com/graphql-python/graphql-core-next/blob/master/graphql/language/ast.py#L261",children:"here"}),")."]}),"\n",(0,a.jsxs)(r.p,{children:["Logic implemented in the ",(0,a.jsx)(r.code,{children:"parse_datetime_literal"})," may be completely different from that in the ",(0,a.jsx)(r.code,{children:"parse_datetime_value"}),", however, in this example the ",(0,a.jsx)(r.code,{children:"ast"})," node is simply unpacked, coerced to ",(0,a.jsx)(r.code,{children:"str"})," and then passed to ",(0,a.jsx)(r.code,{children:"parse_datetime_value"}),", reusing the parsing logic."]}),"\n",(0,a.jsxs)(r.blockquote,{children:["\n",(0,a.jsxs)(r.p,{children:["Defining a ",(0,a.jsx)(r.code,{children:"literal_parser"})," that only calls ",(0,a.jsx)(r.code,{children:"value_parser"})," with ",(0,a.jsx)(r.code,{children:"ast.value"})," is optional. Ariadne will create one for you when you set the scalar's value parser and there's no literal parser already set."]}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"configuration-reference",children:"Configuration reference"}),"\n",(0,a.jsxs)(r.p,{children:["In addition to the decorators documented above, ",(0,a.jsx)(r.code,{children:"ScalarType"})," provides two more ways for configuring its logic."]}),"\n",(0,a.jsxs)(r.p,{children:["You can pass your functions as values to ",(0,a.jsx)(r.code,{children:"serializer"}),", ",(0,a.jsx)(r.code,{children:"value_parser"})," and ",(0,a.jsx)(r.code,{children:"literal_parser"})," keyword arguments on instantiation:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:'from ariadne import ScalarType\nfrom thirdpartylib import json_serialize_money, json_deserialize_money\n\nmoney = ScalarType("Money", serializer=json_serialize_money, value_parser=json_deserialize_money)\n'})}),"\n",(0,a.jsxs)(r.p,{children:["Alternatively you can use ",(0,a.jsx)(r.code,{children:"set_serializer"}),", ",(0,a.jsx)(r.code,{children:"set_value_parser"})," and ",(0,a.jsx)(r.code,{children:"set_literal_parser"})," setters:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:'from ariadne import ScalarType\nfrom thirdpartylib import json_serialize_money, json_deserialize_money\n\nmoney = ScalarType("Money")\nmoney.set_serializer(json_serialize_money)\nmoney.set_value_parser(json_deserialize_money)\nmoney.set_literal_parser(json_deserialize_money)\n'})})]})}function h(e={}){let{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},84429:function(e,r,s){s.d(r,{R:()=>i,x:()=>l});var n=s(96540);let a={},t=n.createContext(a);function i(e){let r=n.useContext(t);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(t.Provider,{value:r},e.children)}}}]);