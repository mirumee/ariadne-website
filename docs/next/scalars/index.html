<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Custom scalars · Ariadne</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;GraphQL standard describes plenty of default GraphQL scalars: &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;Boolean&lt;/code&gt; to name a few. But what when those types are not enough for our API?&lt;/p&gt;
"/><meta name="docsearch:version" content="next"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Custom scalars · Ariadne"/><meta property="og:type" content="website"/><meta property="og:url" content="https://ariadnegraphql.org/"/><meta property="og:description" content="&lt;p&gt;GraphQL standard describes plenty of default GraphQL scalars: &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;Boolean&lt;/code&gt; to name a few. But what when those types are not enough for our API?&lt;/p&gt;
"/><meta property="og:image" content="https://ariadnegraphql.org/img/share-image.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://ariadnegraphql.org/img/twitter-image.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://ariadnegraphql.org/blog/atom.xml" title="Ariadne Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://ariadnegraphql.org/blog/feed.xml" title="Ariadne Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-10159761-23', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/css/prism.css"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo-horizontal.png" alt="Ariadne"/></a><a href="/versions"><h3>next</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class="siteNavGroupActive"><a href="/docs/next/intro" target="_self">Docs</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class=""><a href="/community" target="_self">Community</a></li><li class=""><a href="https://github.com/mirumee/ariadne" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Docs</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Docs</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/next/intro">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/next/resolvers">Resolvers</a></li><li class="navListItem"><a class="navItem" href="/docs/next/mutations">Mutations</a></li><li class="navListItem"><a class="navItem" href="/docs/next/error-messaging">Error messaging</a></li><li class="navListItem"><a class="navItem" href="/docs/next/case-conversion">Name case conversion</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/next/scalars">Custom scalars</a></li><li class="navListItem"><a class="navItem" href="/docs/next/enums">Enumeration types</a></li><li class="navListItem"><a class="navItem" href="/docs/next/unions">Union types</a></li><li class="navListItem"><a class="navItem" href="/docs/next/interfaces">Interface types</a></li><li class="navListItem"><a class="navItem" href="/docs/next/subscriptions">Subscriptions</a></li><li class="navListItem"><a class="navItem" href="/docs/next/dataloaders">Dataloaders</a></li><li class="navListItem"><a class="navItem" href="/docs/next/file-uploads">File uploads</a></li><li class="navListItem"><a class="navItem" href="/docs/next/documenting-schema">Documenting schema</a></li><li class="navListItem"><a class="navItem" href="/docs/next/modularization">Modularization</a></li><li class="navListItem"><a class="navItem" href="/docs/next/bindables">Bindables</a></li><li class="navListItem"><a class="navItem" href="/docs/next/schema-directives">Schema directives</a></li><li class="navListItem"><a class="navItem" href="/docs/next/local-development">Local development</a></li><li class="navListItem"><a class="navItem" href="/docs/next/logging">Logging</a></li><li class="navListItem"><a class="navItem" href="/docs/next/explorers">GraphQL explorers</a></li><li class="navListItem"><a class="navItem" href="/docs/next/apollo-federation">Apollo Federation</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Monitoring</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/next/apollo-tracing">Apollo Tracing</a></li><li class="navListItem"><a class="navItem" href="/docs/next/open-tracing">OpenTracing</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Security</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/next/security-overview">Security Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/next/hiding-field-suggestions">Hiding field suggestions</a></li><li class="navListItem"><a class="navItem" href="/docs/next/disabling-stack-traces">Disabling stack traces</a></li><li class="navListItem"><a class="navItem" href="/docs/next/continuous-security-testing">Continuous security testing</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Servers</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/next/asgi">ASGI application</a></li><li class="navListItem"><a class="navItem" href="/docs/next/wsgi">WSGI application</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Integrations</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/next/django-integration">Django</a></li><li class="navListItem"><a class="navItem" href="/docs/next/fastapi-integration">FastAPI</a></li><li class="navListItem"><a class="navItem" href="/docs/next/flask-integration">Flask</a></li><li class="navListItem"><a class="navItem" href="/docs/next/starlette-integration">Starlette</a></li><li class="navListItem"><a class="navItem" href="/docs/next/other-integrations">Other technologies</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extensions</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/next/extensions">Extension system</a></li><li class="navListItem"><a class="navItem" href="/docs/next/middleware">Middleware</a></li><li class="navListItem"><a class="navItem" href="/docs/next/query-validators">Query validators</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API reference</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/next/api-reference">ariadne</a></li><li class="navListItem"><a class="navItem" href="/docs/next/asgi-reference">ariadne.asgi</a></li><li class="navListItem"><a class="navItem" href="/docs/next/asgi-handlers-reference">ariadne.asgi.handlers</a></li><li class="navListItem"><a class="navItem" href="/docs/next/constants-reference">ariadne.constants</a></li><li class="navListItem"><a class="navItem" href="/docs/next/exceptions-reference">ariadne.exceptions</a></li><li class="navListItem"><a class="navItem" href="/docs/next/types-reference">ariadne.types</a></li><li class="navListItem"><a class="navItem" href="/docs/next/wsgi-reference">ariadne.wsgi</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Other</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/next/logo">Ariadne logo</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Custom scalars</h1></header><article><div><span><p>GraphQL standard describes plenty of default GraphQL scalars: <code>Int</code>, <code>String</code> or <code>Boolean</code> to name a few. But what when those types are not enough for our API?</p>
<p>This is where custom scalars enter the stage, enabling better control on how Python objects and values are represented in GraphQL query inputs and results.</p>
<h2><a class="anchor" aria-hidden="true" id="basic-custom-scalar"></a><a href="#basic-custom-scalar" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Basic custom scalar</h2>
<p>The minimum work required to add custom scalar to GraphQL server is to declare it in the schema using the <code>scalar</code> keyword:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">scalar</span> <span class="token class-name">Money</span>

<span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
    <span class="token attr-name">revenue</span><span class="token punctuation">:</span> Money
<span class="token punctuation">}</span>
</code></pre>
<p>In the above example we have declared custom scalar named <code>Money</code> and used it as an return value for <code>revenue</code> field defined on the <code>Query</code> type.</p>
<p>What will happen now if we will return any value from our <code>revenue</code> resolver and query for it?</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resolve_revenue</span><span class="hljs-params">(*_)</span>:</span>
    revenue = get_revenue()
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"amount"</span>: revenue, <span class="hljs-string">"currency"</span>: DEFAULT_CURRENCY}
</code></pre>
<pre><code class="hljs css language-graphql"><span class="token keyword">query</span> <span class="token punctuation">{</span>
    revenue
<span class="token punctuation">}</span>
</code></pre>
<p>We will find that our value will be JSON-serialized:</p>
<pre><code class="hljs css language-json">{
    <span class="hljs-attr">"data"</span>: {
        <span class="hljs-attr">"revenue"</span>: {
            <span class="hljs-attr">"amount"</span>: <span class="hljs-number">10.5</span>,
            <span class="hljs-attr">"currency"</span>: <span class="hljs-string">"USD"</span>
        }
    }
}
</code></pre>
<p>This is a default behaviour for custom scalars: their values are JSON-serialized when included in query results.</p>
<p>If resolver returns value that's not JSON serializable, GraphQL server will fail while creating Query result, and will return error 500 to the client, with error similar to one below being logged by the application:</p>
<pre><code class="hljs">TypeError: Object of<span class="hljs-built_in"> type </span>date is <span class="hljs-keyword">not</span> JSON serializable
</code></pre>
<p>If value for our scalar appears in JSON with variables, its JSON representation will parsed. Likewise, if value appears within query, its AST (abstract syntax tree) representation will be automatically converted to matching Python representation:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">scalar</span> <span class="token class-name">Money</span>

<span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
    <span class="token attr-name">revenue</span><span class="token punctuation">:</span> Money
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Mutation</span> <span class="token punctuation">{</span>
    <span class="token attr-name">postSale</span><span class="token punctuation">(</span><span class="token attr-name">price</span><span class="token punctuation">:</span> Money<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token attr-name">ref</span><span class="token punctuation">:</span> String<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Boolean
<span class="token punctuation">}</span>
</code></pre>
<pre><code class="hljs css language-graphql"><span class="token keyword">mutation</span> PostSale <span class="token punctuation">{</span>
    postSale<span class="token punctuation">(</span><span class="token attr-name">price</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token attr-name">amount</span><span class="token punctuation">:</span> <span class="token number">9.99</span><span class="token punctuation">,</span> <span class="token attr-name">currency</span><span class="token punctuation">:</span> <span class="token string">"USD"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"usd-2412"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resolve_post_sale</span><span class="hljs-params">(*_, price, ref)</span>:</span>
    repr(price)  <span class="hljs-comment"># {'amount': 9.99, 'currency': 'USD'}</span>
</code></pre>
<p>If JSON with variables or Query AST is incorrect the server will return <code>400 BAD REQUEST</code> and will not attempt to execute query.</p>
<h2><a class="anchor" aria-hidden="true" id="customizing-scalar-serialization"></a><a href="#customizing-scalar-serialization" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Customizing scalar serialization</h2>
<p>Consider this API defining the <code>Story</code> type with the <code>publishedOn</code> field thats date of story publication:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">type</span> <span class="token class-name">Story</span> <span class="token punctuation">{</span>
    <span class="token attr-name">content</span><span class="token punctuation">:</span> String
    <span class="token attr-name">publishedOn</span><span class="token punctuation">:</span> String
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>publishedOn</code> field resolver returns an instance of type <code>datetime</code>, but in the API this field is defined as <code>String</code>. This means that our datetime will be passed through the <code>str()</code> function before being returned to the client:</p>
<pre><code class="hljs css language-json">{
    <span class="hljs-attr">"publishedOn"</span>: <span class="hljs-string">"2018-10-26 17:28:54.416434"</span>
}
</code></pre>
<p>This may look acceptable, but there are better formats to serialize timestamps for later deserialization on the client, like ISO 8601. This conversion could be performed in a dedicated resolver:</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resolve_published_on</span><span class="hljs-params">(obj, *_)</span>:</span>
    <span class="hljs-keyword">return</span> obj.published_on.isoformat()
</code></pre>
<p>However, the developer now has to remember to define a custom resolver for every field that returns <code>datetime</code>. This really adds boilerplate to the API, and makes it harder to use abstractions auto-generating the resolvers for you.</p>
<p>Instead, GraphQL API can be told how to serialize dates by defining the custom scalar type:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">scalar</span> <span class="token class-name">Datetime</span>

<span class="token keyword">type</span> <span class="token class-name">Story</span> <span class="token punctuation">{</span>
    <span class="token attr-name">content</span><span class="token punctuation">:</span> String
    <span class="token attr-name">publishedOn</span><span class="token punctuation">:</span> Datetime
<span class="token punctuation">}</span>
</code></pre>
<p>If you try to query this field now, the server will crash with error 500 and following error will be logged:</p>
<pre><code class="hljs">TypeError: Object of<span class="hljs-built_in"> type </span>date is <span class="hljs-keyword">not</span> JSON serializable
</code></pre>
<p>This is because a custom scalar has been defined, but it's currently missing logic for serializing Python values to JSON form and <code>Datetime</code> instances are not JSON serializable by default.</p>
<p>We need to tell our GraphQL server how <code>Datetime</code> scalar values should be converted in order for them to be JSON serializable.</p>
<p>Ariadne provides the <code>ScalarType</code> class that enables us to implement this behaviour using Python function:</p>
<pre><code class="hljs css language-python"><span class="hljs-keyword">from</span> ariadne <span class="hljs-keyword">import</span> ScalarType

datetime_scalar = ScalarType(<span class="hljs-string">"Datetime"</span>)

<span class="hljs-meta">@datetime_scalar.serializer</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize_datetime</span><span class="hljs-params">(value)</span>:</span>
    <span class="hljs-keyword">return</span> value.isoformat()
</code></pre>
<p>Now we need to include the <code>datetime_scalar</code> on the executable schema creation:</p>
<pre><code class="hljs css language-python">schema = make_executable_schema(type_defs, some_type, some_other_type, datetime_scalar)
</code></pre>
<p>Custom serialization logic will now be used when a resolver for the <code>Datetime</code> field returns a value other than <code>None</code>:</p>
<pre><code class="hljs css language-json">{
    <span class="hljs-attr">"publishedOn"</span>: <span class="hljs-string">"2018-10-26T17:45:08.805278"</span>
}
</code></pre>
<p>We can now reuse our custom scalar across the API to serialize <code>datetime</code> instances in a standardized format that our clients will understand.</p>
<h2><a class="anchor" aria-hidden="true" id="scalars-as-input"></a><a href="#scalars-as-input" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scalars as input</h2>
<p>What will happen if now we create a field or mutation that defines an argument of the type <code>Datetime</code>? We can find out using a basic resolver:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
    <span class="token attr-name">stories</span><span class="token punctuation">(</span><span class="token attr-name">publishedOn</span><span class="token punctuation">:</span> Datetime<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Story<span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resolve_stories</span><span class="hljs-params">(*_, **data)</span>:</span>
    print(data.get(<span class="hljs-string">"publishedOn"</span>))  <span class="hljs-comment"># what value will "publishedOn" be?</span>
</code></pre>
<p><code>data.get(&quot;publishedOn&quot;)</code> will print a result of JSON parsing whatever value was passed to the field. It may be a string with ISO 8601 representation of date but it may also be an integer, float, or some complex type like dict or list.</p>
<p>We will need to add custom parsing logic on top of whatever JSON and GraphQL parsers are doing in order for our scalar to be helpful. To do that, we will need to implement another Python function called <em>&quot;value parser&quot;</em> and use <code>ScalarType</code> that was created in the previous step to make GraphQL server use it for parsing incoming value:</p>
<pre><code class="hljs css language-python"><span class="hljs-meta">@datetime_scalar.value_parser</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_datetime_value</span><span class="hljs-params">(value)</span>:</span>
    <span class="hljs-comment"># dateutil is provided by python-dateutil library</span>
    <span class="hljs-keyword">return</span> dateutil.parser.parse(value)
</code></pre>
<p>There are a few things happening in the above code, so let's go through it step by step:</p>
<ol>
<li>If the <code>value</code> is passed as part of a query's <code>variables</code>, <code>parse_datetime_value</code> will be called with it as only argument, but only if its not <code>null</code>.</li>
<li><code>dateutil.parser.parse</code> is used to parse it to the valid Python <code>datetime</code> object instance that is then returned.</li>
<li>If <code>value</code> is incorrect and either a <code>ValueError</code> or <code>TypeError</code> exception is raised by the <code>dateutil.parser.parse</code>.</li>
</ol>
<p>If error was raised, the GraphQL server interprets this as a sign that the entered value is incorrect because it can't be transformed to an internal representation and returns an automatically generated error message to the client:</p>
<pre><code class="hljs">Expected<span class="hljs-built_in"> type </span>Datetime!, found <span class="hljs-string">"invalid string"</span>: time data <span class="hljs-string">'invalid string'</span> does <span class="hljs-keyword">not</span> match format <span class="hljs-string">'%Y-%m-%d'</span>
</code></pre>
<p>An error will also be logged:</p>
<pre><code class="hljs"><span class="hljs-built_in">time</span> data <span class="hljs-string">'invalid string'</span> does <span class="hljs-keyword">not</span> <span class="hljs-built_in">match</span> <span class="hljs-built_in">format</span> <span class="hljs-string">'%Y-%m-%d'</span>
</code></pre>
<p>Because the error message returned by the GraphQL server includes the original exception message from your Python code, it may contain details specific to your system or implementation that you may not want to make known to the API consumers. You may decide to catch the original exception with <code>except (ValueError, TypeError)</code> and then raise your own <code>ValueError</code> with a custom message (or no message at all) to prevent this from happening:</p>
<pre><code class="hljs css language-python"><span class="hljs-meta">@datetime_scalar.value_parser</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_datetime_value</span><span class="hljs-params">(value)</span>:</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">return</span> dateutil.parser.parse(value)
    <span class="hljs-keyword">except</span> (ValueError, TypeError):
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f'"<span class="hljs-subst">{value}</span>" is not a valid ISO 8601 string'</span>)
</code></pre>
<blockquote>
<p>There is no difference in handling between <code>ValueError</code> and <code>TypeError</code>. Both will produce the same error message in Query result.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="configuration-reference"></a><a href="#configuration-reference" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Configuration reference</h2>
<p>In addition to the decorators documented above, <code>ScalarType</code> provides two more ways for configuring its logic.</p>
<p>You can pass your functions as values to <code>serializer</code>, <code>value_parser</code> keyword arguments on instantiation:</p>
<pre><code class="hljs css language-python"><span class="hljs-keyword">from</span> ariadne <span class="hljs-keyword">import</span> ScalarType
<span class="hljs-keyword">from</span> thirdpartylib <span class="hljs-keyword">import</span> json_serialize_money, json_deserialize_money

money = ScalarType(<span class="hljs-string">"Money"</span>, serializer=json_serialize_money, value_parser=json_deserialize_money)
</code></pre>
<p>Alternatively you can use <code>set_serializer</code>, <code>set_value_parser</code> setters:</p>
<pre><code class="hljs css language-python"><span class="hljs-keyword">from</span> ariadne <span class="hljs-keyword">import</span> ScalarType
<span class="hljs-keyword">from</span> thirdpartylib <span class="hljs-keyword">import</span> json_serialize_money, json_deserialize_money

money = ScalarType(<span class="hljs-string">"Money"</span>)
money.set_serializer(json_serialize_money)
money.set_value_parser(json_deserialize_money)
</code></pre>
<blockquote>
<p><strong>Note:</strong> the previous versions of this document also introduced the <code>literal_parser</code>. However in the light of <code>literal_parser</code> <a href="https://github.com/graphql/graphql-js/issues/2567">reference documentation being incorrect</a> and the usefulness of custom literal parsers <a href="https://github.com/graphql/graphql-js/issues/2657">being discussed</a> we've decided to no longer document it in this article.</p>
<p>GraphQL query executor provides default literal parser for all scalars that converts <code>AST</code> to Python value then calls scalar's value parser with it, making implementation of custom literal parsers for scalars unnecessary.</p>
</blockquote>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/next/case-conversion"><span class="arrow-prev">← </span><span>Name case conversion</span></a><a class="docs-next button" href="/docs/next/enums"><span>Enumeration types</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#basic-custom-scalar">Basic custom scalar</a></li><li><a href="#customizing-scalar-serialization">Customizing scalar serialization</a></li><li><a href="#scalars-as-input">Scalars as input</a></li><li><a href="#configuration-reference">Configuration reference</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/icon.png" alt="Ariadne" height="107" width="128"/></a><div class="footerNavSpacer"></div><div class="footerNavTwoColumn"><h5>Documentation</h5><a href="/docs/intro.html">Introduction</a><a href="/docs/resolvers.html">Resolvers</a><a href="/docs/mutations.html">Mutations</a><a href="/docs/subscriptions.html">Subscriptions</a><a href="/docs/django-integration.html">Django integration</a><a href="/docs/flask-integration.html">Flask integration</a><a href="/docs/starlette-integration.html">Starlette integration</a><a href="/docs/other-integrations.html">Other integrations</a><a href="/docs/api-reference.html">API Reference</a><a href="/docs/logo.html">Logo</a></div><div><h5>Community</h5><a href="https://github.com/mirumee/ariadne/discussions/">Discuss</a><a href="https://github.com/mirumee/ariadne">GitHub</a><a class="github-button" href="https://github.com/mirumee/ariadne" data-icon="octicon-star" data-count-href="/mirumee/ariadne/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright"><a href="https://mirumee.com">Copyright © 2023 Mirumee Software</a><a href="https://mirumee.com">Ariadne is crafted with love by<img src="/img/mirumee.png" alt="Mirumee"/></a></section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '507581234da84aebc8fe9918f530b714',
                indexName: 'ariadnegraphql',
                inputSelector: '#search_input_react'
              });
            </script></body></html>