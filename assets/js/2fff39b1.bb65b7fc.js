"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["94749"],{83900:function(e,n,r){r.r(n),r.d(n,{frontMatter:()=>l,toc:()=>o,default:()=>h,metadata:()=>s,assets:()=>c,contentTitle:()=>a});var s=JSON.parse('{"id":"interfaces","title":"Interface types","description":"Interface is an abstract GraphQL type that defines certain set of fields and requires other types implementing it to also define same fields in order for schema to be correct.","source":"@site/server_versioned_docs/version-0.5.0/interfaces.md","sourceDirName":".","slug":"/interfaces","permalink":"/server/0.5.0/interfaces","draft":false,"unlisted":false,"tags":[],"version":"0.5.0","frontMatter":{"id":"interfaces","title":"Interface types"},"sidebar":"tutorialSidebar","previous":{"title":"Union types","permalink":"/server/0.5.0/unions"},"next":{"title":"Subscriptions","permalink":"/server/0.5.0/subscriptions"}}'),t=r(74848),i=r(84429);let l={id:"interfaces",title:"Interface types"},a,c={},o=[{value:"Interface example",id:"interface-example",level:2},{value:"Field resolvers",id:"field-resolvers",level:2}];function d(e){let n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Interface is an abstract GraphQL type that defines certain set of fields and requires other types ",(0,t.jsx)(n.em,{children:"implementing"})," it to also define same fields in order for schema to be correct."]}),"\n",(0,t.jsx)(n.h2,{id:"interface-example",children:"Interface example"}),"\n",(0,t.jsxs)(n.p,{children:["Consider an application implementing a search function. Search can return items of different type, like ",(0,t.jsx)(n.code,{children:"Client"}),", ",(0,t.jsx)(n.code,{children:"Order"})," or ",(0,t.jsx)(n.code,{children:"Product"}),". For each result it displays a short summary text that is a link leading to a page containing the item's details."]}),"\n",(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)(n.code,{children:"Interface"})," can be defined in schema that forces those types to define the ",(0,t.jsx)(n.code,{children:"summary"})," and ",(0,t.jsx)(n.code,{children:"url"})," fields:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"interface SearchResult {\n    summary: String!\n    url: String!\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Type definitions can then be updated to ",(0,t.jsx)(n.code,{children:"implement"})," this interface:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"type Client implements SearchResult {\n    first_name: String!\n    last_name: String!\n    summary: String!\n    url: String!\n}\n\ntype Order implements SearchResult {\n    ref: String!\n    client: Client!\n    summary: String!\n    url: String!\n}\n\ntype Product implements SearchResult {\n    name: String!\n    sku: String!\n    summary: String!\n    url: String!\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["GraphQL standard requires that every type implementing the ",(0,t.jsx)(n.code,{children:"Interface"})," also explicitly defines fields from the interface. This is why the ",(0,t.jsx)(n.code,{children:"summary"})," and ",(0,t.jsx)(n.code,{children:"url"})," fields repeat on all types in the example."]}),"\n",(0,t.jsxs)(n.p,{children:["Like with the union, the ",(0,t.jsx)(n.code,{children:"SearchResult"})," interface will also need a special resolver named ",(0,t.jsx)(n.em,{children:"type resolver"}),". This resolver will we called with an object returned from a field resolver and current context, and should return a string containing the name of a GraphQL type, or ",(0,t.jsx)(n.code,{children:"None"})," if the received type is incorrect:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def resolve_search_result_type(obj, *_):\n    if isinstance(obj, Client):\n        return "Client"\n    if isinstance(obj, Order):\n        return "Order"\n    if isinstance(obj, Product):\n        return "Product"\n    return None\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Returning ",(0,t.jsx)(n.code,{children:"None"})," from this resolver will result in ",(0,t.jsx)(n.code,{children:"null"})," being returned for this field in your query's result. If a field is not nullable, this will cause the GraphQL query to error."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Ariadne relies on a dedicated ",(0,t.jsx)(n.code,{children:"InterfaceType"})," class for binding this function to the ",(0,t.jsx)(n.code,{children:"Interface"})," in your schema:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from ariadne import InterfaceType\n\nsearch_result = InterfaceType("SearchResult")\n\n@search_result.type_resolver\ndef resolve_search_result_type(obj, *_):\n    ...\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If this function is already defined elsewhere (e.g. 3rd party package), you can instantiate the ",(0,t.jsx)(n.code,{children:"InterfaceType"})," with it as a second argument:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from ariadne import InterfaceType\nfrom .graphql import resolve_search_result_type\n\nsearch_result = InterfaceType("SearchResult", resolve_search_result_type)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Lastly, your ",(0,t.jsx)(n.code,{children:"InterfaceType"})," instance should be passed to ",(0,t.jsx)(n.code,{children:"make_executable_schema"})," together with other types:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"schema = make_executable_schema(type_defs, [query, search_result])\n"})}),"\n",(0,t.jsx)(n.h2,{id:"field-resolvers",children:"Field resolvers"}),"\n",(0,t.jsxs)(n.p,{children:["Ariadne's ",(0,t.jsx)(n.code,{children:"InterfaceType"})," instances can optionally be used to set resolvers on implementing types fields."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"SearchResult"})," interface from previous section implements two fields: ",(0,t.jsx)(n.code,{children:"summary"})," and ",(0,t.jsx)(n.code,{children:"url"}),". If resolver implementation for those fields is same for multiple types implementing the interface, ",(0,t.jsx)(n.code,{children:"InterfaceType"})," instance can be used to set those resolvers for those fields:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'@search_result.field("summary")\ndef resolve_summary(obj, *_):\n    return str(obj)\n\n\n@search_result.field("url")\ndef resolve_url(obj, *_):\n    return obj.get_absolute_url()\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"InterfaceType"})," extends the ",(0,t.jsx)(n.a,{href:"/server/0.5.0/resolvers",children:"ObjectType"}),", so ",(0,t.jsx)(n.code,{children:"set_field"})," and ",(0,t.jsx)(n.code,{children:"set_alias"})," are also available:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'search_result.set_field("summary", resolve_summary)\nsearch_result.alias("url", "absolute_url")\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"InterfaceType"})," assigns the resolver to a field only if that field has no resolver already set. This is different from ",(0,t.jsx)(n.code,{children:"ObjectType"})," that sets resolvers fields if field already has other resolver set."]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},84429:function(e,n,r){r.d(n,{R:()=>l,x:()=>a});var s=r(96540);let t={},i=s.createContext(t);function l(e){let n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);