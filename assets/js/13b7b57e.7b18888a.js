"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["44970"],{1523:function(e,n,s){s.r(n),s.d(n,{frontMatter:()=>i,toc:()=>l,default:()=>h,metadata:()=>o,assets:()=>c,contentTitle:()=>a});var o=JSON.parse('{"id":"subscriptions","title":"Subscriptions","description":"Let\'s introduce a third type of operation. While queries offer a way to query a server once, subscriptions offer a way for the server to notify the client each time new data is available.","source":"@site/docs/server/subscriptions.md","sourceDirName":".","slug":"/subscriptions","permalink":"/server/next/subscriptions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"subscriptions","title":"Subscriptions"},"sidebar":"tutorialSidebar","previous":{"title":"Interface types","permalink":"/server/next/interfaces"},"next":{"title":"Dataloaders","permalink":"/server/next/dataloaders"}}'),r=s(74848),t=s(84429);let i={id:"subscriptions",title:"Subscriptions"},a,c={},l=[{value:"Subscription protocols",id:"subscription-protocols",level:2},{value:"<code>subscriptions-transport-ws</code>",id:"subscriptions-transport-ws",level:3},{value:"<code>graphql-ws</code>",id:"graphql-ws",level:3},{value:"Defining subscriptions",id:"defining-subscriptions",level:2},{value:"Writing subscriptions",id:"writing-subscriptions",level:2},{value:"Publisher-consumer",id:"publisher-consumer",level:2},{value:"Simple pub-sub setup with Broadcaster",id:"simple-pub-sub-setup-with-broadcaster",level:3},{value:"Publisher",id:"publisher",level:3},{value:"Subscriber",id:"subscriber",level:3},{value:"Simple chat example:",id:"simple-chat-example",level:3},{value:"Connection params",id:"connection-params",level:2},{value:"Using <code>on_connect</code> to access connection&#39;s parameters",id:"using-on_connect-to-access-connections-parameters",level:3},{value:"<code>on_connect</code> vs <code>context_value</code>",id:"on_connect-vs-context_value",level:3},{value:"Refusing websocket connection",id:"refusing-websocket-connection",level:2},{value:"<code>on_operation</code> and <code>on_complete</code>",id:"on_operation-and-on_complete",level:2},{value:"<code>on_disconnect</code>",id:"on_disconnect",level:2},{value:"Using Server-Sent Events Protocol",id:"using-server-sent-events-protocol",level:2}];function d(e){let n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Let's introduce a third type of operation. While queries offer a way to query a server once, subscriptions offer a way for the server to notify the client each time new data is available."}),"\n",(0,r.jsxs)(n.p,{children:["This is where the ",(0,r.jsx)(n.code,{children:"Subscription"})," type is useful. It's similar to ",(0,r.jsx)(n.code,{children:"Query"})," but as each subscription remains an open channel you can send anywhere from zero to millions of responses over its lifetime."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Because of their nature, subscriptions are only possible to implement in asynchronous servers that implement the WebSockets protocol.\n(If you are using ",(0,r.jsx)(n.code,{children:"uvicorn"})," you need to ",(0,r.jsx)(n.code,{children:"pip install websockets"})," otherwise you'll get ",(0,r.jsx)(n.code,{children:"Could not connect to websocket endpoint ws://localhost:8000/. Please check if the endpoint url is correct."}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"WSGI"}),"-based servers (including Django) are synchronous in nature and ",(0,r.jsx)(n.em,{children:"unable"})," to handle WebSockets which makes them incapable of implementing subscriptions."]}),"\n",(0,r.jsxs)(n.p,{children:["If you wish to use subscriptions with Django, consider wrapping your Django application in a Django Channels container and using Ariadne as an ",(0,r.jsx)(n.em,{children:"ASGI"})," server."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"subscription-protocols",children:"Subscription protocols"}),"\n",(0,r.jsx)(n.p,{children:"In the world of GraphQL clients, there are two subscription protocols that clients can implement for subscribing to GraphQL server."}),"\n",(0,r.jsx)(n.h3,{id:"subscriptions-transport-ws",children:(0,r.jsx)(n.code,{children:"subscriptions-transport-ws"})}),"\n",(0,r.jsx)(n.p,{children:"Default protocol used by Ariadne. Client library for it is still widely used although no it's no longer maintained. It has benefit of being supported by GraphQL-Playground out of the box."}),"\n",(0,r.jsxs)(n.p,{children:["Repo link: ",(0,r.jsx)(n.a,{href:"https://github.com/apollographql/subscriptions-transport-ws",children:"apollographql/subscriptions-transport-ws"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from ariadne.asgi import GraphQL\nfrom ariadne.asgi.handlers import GraphQLWSHandler\n\n\ngraphql_app = GraphQL(\n    schema,\n    websocket_handler=GraphQLWSHandler(),\n)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"graphql-ws",children:(0,r.jsx)(n.code,{children:"graphql-ws"})}),"\n",(0,r.jsxs)(n.p,{children:["New protocol that replaced ",(0,r.jsx)(n.code,{children:"subscriptions-transport-ws"}),". Its actively maintained and supported by Apollo Studio Explorer."]}),"\n",(0,r.jsxs)(n.p,{children:["Repo link: ",(0,r.jsx)(n.a,{href:"https://github.com/enisdenjo/graphql-ws",children:"enisdenjo/graphql-ws"})]}),"\n",(0,r.jsxs)(n.p,{children:["To make Ariadne use ",(0,r.jsx)(n.code,{children:"graphql-ws"})," protocol for subscriptions, initialize ",(0,r.jsx)(n.code,{children:"ariadne.asgi.GraphQL"})," app with ",(0,r.jsx)(n.code,{children:"ariadne.asgi.handlers.GraphQLTransportWSHandler"})," instance:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from ariadne.asgi import GraphQL\nfrom ariadne.asgi.handlers import GraphQLTransportWSHandler\n\n\ngraphql_app = GraphQL(\n    schema,\n    websocket_handler=GraphQLTransportWSHandler(),\n)\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," Name of class implementing ",(0,r.jsx)(n.code,{children:"graphql-ws"})," is not a mistake. The subprotocol used for subscriptions is indeed named ",(0,r.jsx)(n.a,{href:"https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md",children:(0,r.jsx)(n.code,{children:"graphql-transport-ws"})}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"defining-subscriptions",children:"Defining subscriptions"}),"\n",(0,r.jsx)(n.p,{children:"In schema definition subscriptions look similar to queries:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"type Query {\n    _unused: Boolean\n}\n\ntype Subscription {\n    counter: Int!\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This example contains:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Query"})," type with single unused field. GraphQL considers an empty type a syntax error and requires an API to always define a ",(0,r.jsx)(n.code,{children:"Query"})," type.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For this example, we're focusing on ",(0,r.jsx)(n.code,{children:"Subscription"}),"s so we define a bare bones ",(0,r.jsx)(n.code,{children:"Query"})," type."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Subscription"})," type with a single field, ",(0,r.jsx)(n.code,{children:"counter"}),", that returns a number."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When defining subscriptions you can use all of the features of the schema such as arguments, input and output types."}),"\n",(0,r.jsx)(n.h2,{id:"writing-subscriptions",children:"Writing subscriptions"}),"\n",(0,r.jsx)(n.p,{children:"Subscriptions are more complex than queries as they require us to provide two functions for each field:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"generator"})," is a function that yields data we're going to send to the client. It has to implement the ",(0,r.jsx)(n.code,{children:"AsyncGenerator"})," protocol."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"resolver"})," that tells the server how to send data to the client. This is similar to the ",(0,r.jsx)(n.a,{href:"/server/next/resolvers",children:"resolvers we wrote earlier"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Make sure you understand how asynchronous generators work before attempting to use subscriptions."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The signatures are as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"async def counter_generator(obj, info):\n    for i in range(5):\n        await asyncio.sleep(1)\n        yield i\n\n\ndef counter_resolver(count, info):\n    return count + 1\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note that the resolver consumes the same type (in this case ",(0,r.jsx)(n.code,{children:"int"}),") that the generator yields."]}),"\n",(0,r.jsx)(n.p,{children:"Each time our source yields a response, it's getting sent to our resolver. The above implementation counts from zero to four, each time waiting for one second before yielding a value."}),"\n",(0,r.jsx)(n.p,{children:"The resolver increases each number by one before passing them to the client so the client sees the counter progress from one to five."}),"\n",(0,r.jsx)(n.p,{children:"After the last value is yielded the generator returns, the server tells the client that no more data will be available, and the subscription is complete."}),"\n",(0,r.jsxs)(n.p,{children:["We can map these functions to subscription fields using the ",(0,r.jsx)(n.code,{children:"SubscriptionType"})," class that extends ",(0,r.jsx)(n.code,{children:"ObjectType"})," with support for ",(0,r.jsx)(n.code,{children:"source"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from ariadne import SubscriptionType\nfrom . import counter_subscriptions\n\nsubscription = SubscriptionType()\nsubscription.set_field("counter", counter_subscriptions.counter_resolver)\nsubscription.set_source("counter", counter_subscriptions.counter_generator)\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You can also use the ",(0,r.jsx)(n.code,{children:"source"})," decorator:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@subscription.source("counter")\nasync def counter_generator(\n    obj: Any, info: GraphQLResolveInfo\n) -> AsyncGenerator[int, None]:\n    ...\n'})}),"\n",(0,r.jsx)(n.h2,{id:"publisher-consumer",children:"Publisher-consumer"}),"\n",(0,r.jsx)(n.p,{children:'Pubisher-consumer ("pub-sub") is a pattern in which parts of the system listen for ("subscribe to") events ("messages") from other parts of the system, usually reacting to them with very small delay.'}),"\n",(0,r.jsx)(n.p,{children:"To implement subscriptions, you will need to introduce a pub-sub solution to your stack. Multiple technologies are available here, starting with dedicated solutions like Apache Kafka, RabbitMQ and ending with data stores supporting subscribing to updates like Redis and PostgreSQL. Each of those solutions offers different features and trade offs, making them useful for different use-cases."}),"\n",(0,r.jsxs)(n.p,{children:["Only requirement by Ariadne is that technology has Python implementation that supports ",(0,r.jsx)(n.code,{children:"async"})," subscriber."]}),"\n",(0,r.jsx)(n.h3,{id:"simple-pub-sub-setup-with-broadcaster",children:"Simple pub-sub setup with Broadcaster"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/encode/broadcaster",children:"Broadcaster"})," is a simple pub-sub library that supports Redis, PostgreSQL and Apache Kafka as backends. It can be installed with ",(0,r.jsx)(n.code,{children:"pip"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-console",children:"pip install broadcaster\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In our example we will use Redis server running on localhost at port 6379 for messaging. We instantiate ",(0,r.jsx)(n.code,{children:"Broadcaster"})," with connection URL in our app:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'broadcast = Broadcast("redis://localhost:6379")\n'})}),"\n",(0,r.jsxs)(n.p,{children:["We also need to run its ",(0,r.jsx)(n.code,{children:"connect"})," and ",(0,r.jsx)(n.code,{children:"disconnect"})," methods when our ASGI app starts or stops:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"app = Starlette(on_startup=[broadcast.connect], on_shutdown=[broadcast.disconnect])\n"})}),"\n",(0,r.jsx)(n.h3,{id:"publisher",children:"Publisher"}),"\n",(0,r.jsxs)(n.p,{children:["We can publish our messages using the ",(0,r.jsx)(n.code,{children:"publish"})," method:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'await broadcast.publish(channel="chatroom", message="Hello world!")\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," Channels are a way to group publishers and subscribers together. Your system may use single channel or multiple ones, each for different feature."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Where publishing code should live at? Simplest answer is ",(0,r.jsx)(n.em,{children:"at the same place that events occur that you would like your users to subscribe to"}),". Here are few examples:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["In GraphQL mutations: ",(0,r.jsx)(n.code,{children:"postComment"})," mutation could publish event to notify other clients on same page that new commend was posted."]}),"\n",(0,r.jsxs)(n.li,{children:["In task queues: ",(0,r.jsx)(n.code,{children:"process_video_file"})," Celery task could publish event with current progress on processing uploaded video file."]}),"\n",(0,r.jsx)(n.li,{children:"In regular views: your JSON API or standard HTTP form view can send an event that contact form was sent to notify customer service members on-line."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"subscriber",children:"Subscriber"}),"\n",(0,r.jsxs)(n.p,{children:["Unlike publishers, which can go anywhere, subscribers in GraphQL API's have single dedicated place: subscriptions ",(0,r.jsx)(n.em,{children:"source"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@subscription.source("chat")\nasync def chat_generator(\n    _: Any, info: GraphQLResolveInfo\n) -> AsyncGenerator[str, None]:\n    async with broadcast.subscribe(channel="chatroom") as subscriber:\n        async for message in subscriber:\n            yield message\n'})}),"\n",(0,r.jsx)(n.p,{children:"In addition to that, generators can be used to filter which messages should and which shouldn't be sent further to the subscribers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@subscription.source("chat")\nasync def chat_generator(\n    _: Any, info: GraphQLResolveInfo\n) -> AsyncGenerator[str, None]:\n    swearwords = await load_swearwords()\n\n    async with broadcast.subscribe(channel="chatroom") as subscriber:\n        async for message in subscriber:\n            if not contains_swearwords(message, swearwords):\n                yield message\n'})}),"\n",(0,r.jsx)(n.h3,{id:"simple-chat-example",children:"Simple chat example:"}),"\n",(0,r.jsx)(n.p,{children:"Here's example implementing simple GraphQL chat with mutation for sending messages and subscription for receiving them:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import json\n\nfrom ariadne import MutationType, SubscriptionType, make_executable_schema\nfrom ariadne.asgi import GraphQL\nfrom ariadne.asgi.handlers import GraphQLWSHandler\nfrom broadcaster import Broadcast\nfrom starlette.applications import Starlette\n\n\nbroadcast = Broadcast("memory://")\n\n\ntype_defs = """\n  type Query {\n    _unused: Boolean\n  }\n\n  type Message {\n    sender: String\n    message: String\n  }\n\n  type Mutation {\n    send(sender: String!, message: String!): Boolean\n  }\n\n  type Subscription {\n    message: Message\n  }\n"""\n\n\nmutation = MutationType()\n\n\n@mutation.field("send")\nasync def resolve_send(*_, **message):\n    await broadcast.publish(channel="chatroom", message=json.dumps(message))\n    return True\n\n\nsubscription = SubscriptionType()\n\n\n@subscription.source("message")\nasync def source_message(_, info):\n    async with broadcast.subscribe(channel="chatroom") as subscriber:\n        async for event in subscriber:\n            yield json.loads(event.message)\n\n\nschema = make_executable_schema(type_defs, mutation, subscription)\ngraphql = GraphQL(\n    schema=schema,\n    debug=True,\n    websocket_handler=GraphQLWSHandler(),\n)\n\napp = Starlette(\n    debug=True,\n    on_startup=[broadcast.connect],\n    on_shutdown=[broadcast.disconnect],\n)\n\napp.mount("/", graphql)\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," We have expanded the code above into a repository with complete example, including GraphQL server, React.js client, Redis for messaging and Uvicorn HTTP server."]}),"\n",(0,r.jsxs)(n.p,{children:["It can be found on our github: ",(0,r.jsx)(n.a,{href:"https://github.com/mirumee/ariadne-graphql-chat-example",children:"Ariadne GraphQL Chat Example"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"connection-params",children:"Connection params"}),"\n",(0,r.jsxs)(n.p,{children:["Because subscriptions in GraphQL are done over the websockets, you can't use custom HTTP headers to pass additional data from client to server. This makes it impossible to use ",(0,r.jsx)(n.code,{children:"Authorization"})," header for authentication within subscriptions."]}),"\n",(0,r.jsx)(n.p,{children:"To work around this limitation, websocket clients include this data in initial message sent to the server as part of connection negotiation."}),"\n",(0,r.jsxs)(n.h3,{id:"using-on_connect-to-access-connections-parameters",children:["Using ",(0,r.jsx)(n.code,{children:"on_connect"})," to access connection's parameters"]}),"\n",(0,r.jsxs)(n.p,{children:["To access connection parameters, custom function needs to be implemented and passed to Ariadne's ",(0,r.jsx)(n.code,{children:"on_connect"})," option:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from ariadne.asgi.handlers import GraphQLWSHandler\n\n\ndef on_connect(websocket, params: Any):\n    ...\n\n\ngraphql = GraphQL(\n    schema,\n    websocket_handler=GraphQLWSHandler(\n        on_connect=on_connect,\n    ),\n)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This function is called exactly once: at the time when websocket connection is opened by the client. It's always called with two arguments: a ",(0,r.jsx)(n.code,{children:"starlette.websockets.WebSocket"})," instance and a payload. It can be synchronous or asynchronous."]}),"\n",(0,r.jsxs)(n.p,{children:["Please note that because ",(0,r.jsx)(n.code,{children:"params"})," value is set by the client there are no guarantees on what type and concents this value will be. Due care needs to be taken here:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def on_connect(websocket, params: Any):\n    if not isinstance(params, dict):\n        return\n\n    token = params.get("token")\n    if token:\n        ...\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In order to make params available to the resolvers, they need to be passed through the ",(0,r.jsx)(n.code,{children:"WebSocket.scope"})," dict to context factory:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def on_connect(websocket, params: Any):\n    if not isinstance(params, dict):\n        websocket.scope["connection_params"] = {}\n        return\n\n    # websocket.scope is a dict acting as a "bag"\n    # stores data for the duration of connection\n    websocket.scope["connection_params"] = {\n        "token": params.get("token"),\n    }\n\n\ndef context_value(request_or_websocket, data):\n    context = {}\n\n    if request.scope["type"] == "websocket":\n        # request is an instance of WebSocket\n        context.update(request.scope["connection_params"])\n    else:\n        context["token"] = request.META.get("authorization")\n\n    return context\n\n\ngraphql = GraphQL(\n    schema,\n    context_value=context_value,\n    websocket_handler=GraphQLWSHandler(\n        on_connect=on_connect,\n    ),\n)\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"on_connect-vs-context_value",children:[(0,r.jsx)(n.code,{children:"on_connect"})," vs ",(0,r.jsx)(n.code,{children:"context_value"})]}),"\n",(0,r.jsxs)(n.p,{children:["There's important difference between ",(0,r.jsx)(n.code,{children:"on_connect"})," and ",(0,r.jsx)(n.code,{children:"context_value"}),":"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"on_connect"})," is called once, at the time of websocket connection negotiation between client and GraphQL server."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"context_value"})," is called every time new subscription query is made by the client."]}),"\n",(0,r.jsxs)(n.p,{children:["If your client has two separate UI components (eg. notification bell on the navbar and list of on-line users), and those components do GraphQL ",(0,r.jsx)(n.code,{children:"subscribe"})," queries, ",(0,r.jsx)(n.code,{children:"context_value"})," will be ran for each of those separately while ",(0,r.jsx)(n.code,{children:"on_connect"})," will only be ran once."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," This behavior is true for most popular GraphQL client implementations (",(0,r.jsx)(n.code,{children:"gql"})," and Apollo-Client) but may not be true for some libraries."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This can have implications for application performance. It may be preferable to cache data on ",(0,r.jsx)(n.code,{children:"websocket.scope"})," instead of ",(0,r.jsx)(n.code,{children:"info.context"})," to avoid repeated database reads for multiple subscriptions accessing same data. Or pre-load user object in ",(0,r.jsx)(n.code,{children:"on_connect"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"refusing-websocket-connection",children:"Refusing websocket connection"}),"\n",(0,r.jsxs)(n.p,{children:["To refuse websocket connection from client, you can raise ",(0,r.jsx)(n.code,{children:"ariadne.asgi.WebSocketConnectionError"})," from ",(0,r.jsx)(n.code,{children:"on_connect"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def on_connect(websocket, params: Any):\n    if not isinstance(params, dict):\n        raise WebSocketConnectionError("Invalid payload")\n\n    token = params.get("token")\n    if not token:\n        raise WebSocketConnectionError("Missing auth")\n'})}),"\n",(0,r.jsx)(n.p,{children:"If you have control on client implementation as well, you can pass custom error payload instead of string:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def on_connect(websocket, params: Any):\n    if not isinstance(params, dict):\n        raise WebSocketConnectionError({"message": "Invalid payload", "code": "invalid_payload"})\n\n    token = params.get("token")\n    if not token:\n        raise WebSocketConnectionError({"message": "Missing auth", "code": "auth"})\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"on_operation-and-on_complete",children:[(0,r.jsx)(n.code,{children:"on_operation"})," and ",(0,r.jsx)(n.code,{children:"on_complete"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Warning:"})," This feature is considered experimental. It was implemented for feature parity with older version of Apollo Server. Its final shape (or presence in future Ariadne releases) is snot decided yet. Generally you should try using ",(0,r.jsx)(n.code,{children:"on_connect"})," and ",(0,r.jsx)(n.code,{children:"on_disconnect"})," first before using those features."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"on_operation"})," and ",(0,r.jsx)(n.code,{children:"on_complete"})," options allow you to run extra python code when client subscribes or unsubscribes from Subscription field within same WebSocket connection:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def on_operation(websocket, operation: Operation):\n    ...\n\n\ndef on_complete(websocket, operation: Operation):\n    ...\n\n\ngraphql = GraphQL(schema, on_operation=on_operation, on_complete=on_complete)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["First argument for those functions is ",(0,r.jsx)(n.code,{children:"WebSocket"})," instance and second one is ",(0,r.jsx)(n.code,{children:"Operation"})," dataclass storing data about current subscription:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@dataclass\nclass Operation:\n    id: str\n    name: Optional[str]\n    generator: AsyncGenerator\n"})}),"\n",(0,r.jsx)(n.h2,{id:"on_disconnect",children:(0,r.jsx)(n.code,{children:"on_disconnect"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"on_disconnect"})," option can be set to callable function taking single argument, ",(0,r.jsx)(n.code,{children:"WebSocket"})," instance, that should be ran after Ariadne closes the websocket connection:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from ariadne.asgi import GraphQL\nfrom ariadne.asgi.handlers import GraphQLWSHandler\n\n\ndef on_connect(websocket, params: Any):\n    if not isinstance(params, dict):\n        websocket.scope["connection_params"] = {}\n        return\n\n    chat_user = get_user_from_ws(params)\n    chat_user.set_online()\n    websocket.scope["chat_user"] = chat_user\n\n\ndef on_disconnect(websocket):\n    chat_user = websocket.scope.get("chat_user")\n    if chat_user:\n        chat_user.set_offline()\n\n\ngraphql = GraphQL(\n    schema,\n    websocket_handler=GraphQLWSHandler(\n        on_connect=on_connect,\n        on_disconnect=on_disconnect,\n    ),\n)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"using-server-sent-events-protocol",children:"Using Server-Sent Events Protocol"}),"\n",(0,r.jsxs)(n.p,{children:["Instead of WebSockets, ",(0,r.jsx)(n.a,{href:"https://github.com/enisdenjo/graphql-sse/blob/master/PROTOCOL.md",children:"Server-Sent Events (SSE)"})," can be used as a transmission protocol for subscriptions. This approach uses single, long-lived HTTP connection to push data to clients."]}),"\n",(0,r.jsxs)(n.p,{children:["To enable subscriptions over Server-Sent Events, initialize the ",(0,r.jsx)(n.code,{children:"ariadne.asgi.GraphQL"})," app with an ",(0,r.jsx)(n.code,{children:"ariadne.contrib.sse.GraphQLHTTPSSEHandler"})," instance:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\nfrom typing import Any, AsyncGenerator\n\nfrom ariadne import SubscriptionType, make_executable_schema, gql\nfrom ariadne.asgi import GraphQL\nfrom ariadne.contrib.sse import GraphQLHTTPSSEHandler\n\ntype_defs = gql("""\n\n    type Query {\n        _empty: String\n    }\n\n    type Subscription {\n        counter: Int!\n    }\n\n""")\n\nsubscription = SubscriptionType()\n\n\n@subscription.field("counter")\nasync def counter_resolver(count, info: Any) -> AsyncGenerator[int, None]:\n    return count\n\n\n@subscription.source("counter")\nasync def counter_generator(obj: Any, info: Any) -> AsyncGenerator[int, None]:\n    for i in range(5):\n        yield i\n        await asyncio.sleep(1)\n\n\nschema = make_executable_schema(type_defs, [subscription])\napp = GraphQL(schema, http_handler=GraphQLHTTPSSEHandler())\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Subscriptions can be consumed using the ",(0,r.jsx)(n.a,{href:"https://github.com/enisdenjo/graphql-sse/",children:"graphql-sse"})," JavaScript client library or any other compatible implementation."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"GraphQLHTTPSSEHandler"})," requires the ASGI server to work."]}),"\n",(0,r.jsxs)(n.p,{children:["This handler only supports the ",(0,r.jsx)(n.em,{children:"distinct connections"})," mode of the protocol due to Ariadne's stateless implementation."]}),"\n",(0,r.jsxs)(n.p,{children:["If you are using a custom client implementation, make sure to add the ",(0,r.jsx)(n.code,{children:"Accept: text/event-stream"})," header to the request as this is required to establish the Server-Sent Events connection."]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},84429:function(e,n,s){s.d(n,{R:()=>i,x:()=>a});var o=s(96540);let r={},t=o.createContext(r);function i(e){let n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);