"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["73710"],{53426:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>a,toc:()=>o,default:()=>h,metadata:()=>r,assets:()=>c,contentTitle:()=>l});var r=JSON.parse('{"id":"interfaces","title":"Interface types","description":"An interface is an abstract GraphQL type that defines a certain set of fields.  Any other type that contains the same set of fields is said to implement that interface. Types that implement an interface are not limited by it. In other words, a type can implement an interface\'s fields as well as additional fields.  The key point is that a type must implement at least the fields of an interface in order for the schema to be correct.","source":"@site/server_versioned_docs/version-0.24/interfaces.md","sourceDirName":".","slug":"/interfaces","permalink":"/server/0.24/interfaces","draft":false,"unlisted":false,"tags":[],"version":"0.24","frontMatter":{"id":"interfaces","title":"Interface types"},"sidebar":"tutorialSidebar","previous":{"title":"Union types","permalink":"/server/0.24/unions"},"next":{"title":"Subscriptions","permalink":"/server/0.24/subscriptions"}}'),s=t(74848),i=t(84429);let a={id:"interfaces",title:"Interface types"},l,c={},o=[{value:"Interface example",id:"interface-example",level:2},{value:"Field resolvers",id:"field-resolvers",level:2}];function d(e){let n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.code,{children:"interface"})," is an abstract GraphQL type that defines a certain set of fields.  Any other type that contains the same set of fields is said to ",(0,s.jsx)(n.em,{children:"implement"})," that ",(0,s.jsx)(n.code,{children:"interface"}),". Types that implement an ",(0,s.jsx)(n.code,{children:"interface"})," are not limited by it. In other words, a type can implement an ",(0,s.jsx)(n.code,{children:"interface"}),"'s fields as well as additional fields.  The key point is that a type must implement ",(0,s.jsx)(n.strong,{children:"at least"})," the fields of an ",(0,s.jsx)(n.code,{children:"interface"})," in order for the schema to be correct."]}),"\n",(0,s.jsx)(n.h2,{id:"interface-example",children:"Interface example"}),"\n",(0,s.jsxs)(n.p,{children:["Consider an application implementing a search function. Search can return items of different types, like ",(0,s.jsx)(n.code,{children:"Client"}),", ",(0,s.jsx)(n.code,{children:"Order"})," or ",(0,s.jsx)(n.code,{children:"Product"}),". For each result it displays a short summary text that is a link leading to a page containing the item's details."]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.code,{children:"Interface"})," can be defined in the schema that forces those types to define the ",(0,s.jsx)(n.code,{children:"summary"})," and ",(0,s.jsx)(n.code,{children:"url"})," fields:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"interface SearchResult {\n    summary: String!\n    url: String!\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Type definitions can then be updated to ",(0,s.jsx)(n.code,{children:"implement"})," this interface:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"type Client implements SearchResult {\n    first_name: String!\n    last_name: String!\n    summary: String!\n    url: String!\n}\n\ntype Order implements SearchResult {\n    ref: String!\n    client: Client!\n    summary: String!\n    url: String!\n}\n\ntype Product implements SearchResult {\n    name: String!\n    sku: String!\n    summary: String!\n    url: String!\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The GraphQL standard requires that every type implementing the ",(0,s.jsx)(n.code,{children:"Interface"})," also explicitly defines fields from the interface. This is why the ",(0,s.jsx)(n.code,{children:"summary"})," and ",(0,s.jsx)(n.code,{children:"url"})," fields repeat on all types in the example."]}),"\n",(0,s.jsxs)(n.p,{children:["Like with the ",(0,s.jsx)(n.code,{children:"Union"}),", the ",(0,s.jsx)(n.code,{children:"SearchResult"})," interface will also need a special resolver called a ",(0,s.jsx)(n.em,{children:"type resolver"}),". This resolver will be called with an object returned from a field resolver and the current context. It should return a string containing the name of a GraphQL type, or ",(0,s.jsx)(n.code,{children:"None"})," if the received type is incorrect:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def resolve_search_result_type(obj, *_):\n    if isinstance(obj, Client):\n        return "Client"\n    if isinstance(obj, Order):\n        return "Order"\n    if isinstance(obj, Product):\n        return "Product"\n    return None\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Returning ",(0,s.jsx)(n.code,{children:"None"})," from this resolver will result in ",(0,s.jsx)(n.code,{children:"null"})," being returned for this field in your query's result. If a field is not nullable, this will cause the GraphQL query to error."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Ariadne relies on a dedicated ",(0,s.jsx)(n.code,{children:"InterfaceType"})," class for binding this function to the ",(0,s.jsx)(n.code,{children:"Interface"})," in your schema:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from ariadne import InterfaceType\n\nsearch_result = InterfaceType("SearchResult")\n\n@search_result.type_resolver\ndef resolve_search_result_type(obj, *_):\n    ...\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If this function is already defined elsewhere (e.g. 3rd party package), you can instantiate the ",(0,s.jsx)(n.code,{children:"InterfaceType"})," with it as a second argument:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from ariadne import InterfaceType\nfrom .graphql import resolve_search_result_type\n\nsearch_result = InterfaceType("SearchResult", resolve_search_result_type)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Lastly, your ",(0,s.jsx)(n.code,{children:"InterfaceType"})," instance should be passed to ",(0,s.jsx)(n.code,{children:"make_executable_schema"})," together with your other types:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"schema = make_executable_schema(type_defs, [query, search_result])\n"})}),"\n",(0,s.jsx)(n.h2,{id:"field-resolvers",children:"Field resolvers"}),"\n",(0,s.jsxs)(n.p,{children:["Ariadne's ",(0,s.jsx)(n.code,{children:"InterfaceType"})," instances can optionally be used to set resolvers on implementing types' fields."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SearchResult"})," interface from the previous section implements two fields: ",(0,s.jsx)(n.code,{children:"summary"})," and ",(0,s.jsx)(n.code,{children:"url"}),". If the resolver implementation for those fields is same for multiple types implementing the interface, the ",(0,s.jsx)(n.code,{children:"InterfaceType"})," instance can be used to set those resolvers for those fields:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'@search_result.field("summary")\ndef resolve_summary(obj, *_):\n    return str(obj)\n\n\n@search_result.field("url")\ndef resolve_url(obj, *_):\n    return obj.get_absolute_url()\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"InterfaceType"})," extends the ",(0,s.jsx)(n.a,{href:"/server/0.24/resolvers",children:"ObjectType"})," class, so ",(0,s.jsx)(n.code,{children:"set_field"})," and ",(0,s.jsx)(n.code,{children:"set_alias"})," are also available:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'search_result.set_field("summary", resolve_summary)\nsearch_result.alias("url", "absolute_url")\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"InterfaceType"})," assigns the resolver to a field only if that field doesn't already have a resolver set. This is different from an ",(0,s.jsx)(n.code,{children:"ObjectType"})," that can set a resolver to a field even if the field already has another resolver set."]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},84429:function(e,n,t){t.d(n,{R:()=>a,x:()=>l});var r=t(96540);let s={},i=r.createContext(s);function a(e){let n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);